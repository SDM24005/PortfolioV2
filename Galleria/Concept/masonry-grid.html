<!DOCTYPE html>
<html lang="it">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Griglia Masonry</title>
<link rel="icon" type="image/png" href="../../Logo/logo-light.png" media="(prefers-color-scheme: light)">
<link rel="icon" type="image/png" href="../../Logo/logo-dark.png" media="(prefers-color-scheme: dark)">
<style>
    @font-face {
        font-family: 'PPKyoto';
        src: url('../../Fonts/PPKyoto-MediumItalic.otf') format('opentype');
        font-weight: normal;
        font-style: italic;
    }

    @font-face {
        font-family: 'PPKyoto';
        src: url('../../Fonts/PPKyoto-Medium.otf') format('opentype');
        font-weight: normal;
        font-style: normal;
    }

    * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
    }

    body {
        background-color: #000000;
        padding: 20px;
        padding-top: 70px;
    }

    .header {
        position: fixed;
        top: calc(50% - 100px);
        left: 0;
        right: 0;
        height: 70px;
        z-index: 999;
        display: flex;
        align-items: center;
        justify-content: center;
        background-color: #000000;
    }

    .header.loaded {
        animation: moveHeaderToTop 0.5s ease-in-out 0s forwards;
    }

    .header-rectangle {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        height: 70px;
        background-color: #000000;
        opacity: 0;
    }

    .header-rectangle.loaded {
        animation: fadeInHeaderRectangle 0.5s ease-in-out 0s forwards;
    }

    .header-text {
        position: relative;
        z-index: 1000;
        color: white;
        font-size: 48px;
        font-family: 'PPKyoto', sans-serif;
        font-style: italic;
        cursor: pointer;
        transition: opacity 0.3s ease;
        text-decoration: underline;
        text-underline-offset: 2px;
    }

    .header-text:hover {
        opacity: 0.7;
    }

    .logo-circle {
        position: fixed;
        top: 50%;
        left: 50%;
        width: 60px;
        height: 60px;
        transform: translate(-50%, -50%);
        background-color: white;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 1000;
        cursor: pointer;
        animation: rotateLoading 1s ease-in-out infinite;
    }

    .logo-circle.loaded {
        animation: moveToBottomAndRotate 0.5s ease-in-out 0s forwards !important;
    }

    .logo-circle.dragging {
        transition: none;
    }

    .logo-circle img {
        width: 95%;
        height: 95%;
        object-fit: contain;
        display: block;
    }

    .masonry-container {
        display: flex;
        gap: 20px;
        justify-content: center;
    }

    .masonry-column {
        display: flex;
        flex-direction: column;
        gap: 20px;
        flex: 0 0 auto;
    }

    .masonry-item {
        width: 100%;
        opacity: 0;
        transform: translateX(-30px);
    }

    .masonry-item.animate {
        animation: fadeInFromLeft 0.6s ease-out forwards;
    }

    .masonry-item img {
        width: 100%;
        height: auto;
        display: block;
    }

    .masonry-item a {
        display: block;
        width: 100%;
        text-decoration: none;
        cursor: pointer;
        transition: opacity 0.3s ease;
    }

    .masonry-item a:hover {
        opacity: 0.8;
    }

    .gallery-footer {
        margin-top: 40px;
        padding: 20px;
        padding-bottom: 100px;
        text-align: center;
        opacity: 0;
        transition: opacity 0.5s ease-in;
    }

    .gallery-footer.visible {
        opacity: 1;
    }

    .footer-line {
        width: 100%;
        height: 3px;
        background-color: white;
        margin-bottom: 30px;
    }

    .footer-text {
        color: white;
        font-family: sans-serif;
        font-size: 18px;
        margin-bottom: 15px;
        line-height: 1.5;
    }

    .back-to-top {
        color: white;
        font-family: sans-serif;
        font-size: 16px;
        text-decoration: none;
        cursor: pointer;
        display: inline-block;
        transition: opacity 0.3s ease;
    }

    .back-to-top:hover {
        opacity: 0.7;
    }

    .bottom-menu {
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
        background-color: #000000;
        height: 0;
        z-index: 998;
        overflow: hidden;
        transition: height 0.2s ease-out, opacity 0.5s ease-out;
        opacity: 1;
    }

    .bottom-menu.fade-out {
        opacity: 0;
        pointer-events: none;
    }

    .bottom-menu.open {
        height: 400px;
    }
    
    .bottom-menu.dragging {
        transition: none;
    }

    .menu-content {
        padding: 30px 20px 40px 20px;
        display: flex;
        flex-direction: column;
        gap: 10px;
        align-items: center;
        justify-content: flex-start;
        max-width: 1200px;
        margin: 0 auto;
        height: 100%;
    }

    .menu-item {
        color: white;
        font-family: 'PPKyoto', sans-serif;
        font-size: 48px;
        font-style: italic;
        text-decoration: none;
        cursor: pointer;
        transition: text-decoration 0.3s ease;
        text-align: center;
    }

    .menu-item:hover {
        text-decoration: underline;
        text-underline-offset: 2px;
    }

    .menu-item.active {
        text-decoration: underline;
        text-underline-offset: 2px;
    }

    @keyframes fadeInFromTop {
        from {
            opacity: 0;
            transform: translateY(-20px);
        }
        to {
            opacity: 1;
            transform: translateY(0);
        }
    }

    @keyframes moveHeaderToTop {
        from {
            top: calc(50% - 100px);
        }
        to {
            top: 0;
        }
    }

    @keyframes fadeInHeaderRectangle {
        from {
            opacity: 0;
        }
        to {
            opacity: 1;
        }
    }

    @keyframes typewriter {
        from {
            width: 0;
        }
        to {
            width: 100%;
        }
    }


    @keyframes rotateLoading {
        0% {
            transform: translate(-50%, -50%) rotate(0deg);
        }
        80% {
            transform: translate(-50%, -50%) rotate(360deg);
        }
        100% {
            transform: translate(-50%, -50%) rotate(360deg);
        }
    }

    @keyframes moveToBottomAndRotate {
        from {
            top: 50%;
            transform: translate(-50%, -50%) ;
        }
        to {
            top: calc(100vh - 130px);
            transform: translate(-50%, -50%);
        }
    }
    
    /* Animazione ottimizzata per mobile */
    @keyframes moveToBottomAndRotateMobile {
        from {
            top: 50%;
            transform: translate(-50%, -50%);
        }
        to {
            top: calc(100vh - 110px);
            transform: translate(-50%, -50%);
        }
    }

    @keyframes fadeInFromLeft {
        from {
            opacity: 0;
            transform: translateX(-30px);
        }
        to {
            opacity: 1;
            transform: translateX(0);
        }
    }

    @media (max-width: 992px) {
        body {
            padding: 15px;
            padding-top: 75px;
        }
        .masonry-container {
            gap: 15px;
        }
        .masonry-column {
            gap: 15px;
        }
        
        /* Assicura che le animazioni funzionino anche su tablet */
        .logo-circle {
            animation: rotateLoading 1s ease-in-out infinite;
        }
        .logo-circle.loaded {
            animation: moveToBottomAndRotate 0.5s ease-in-out 0s forwards !important;
        }
        .header {
            top: calc(50% - 100px);
        }
        .header.loaded {
            animation: moveHeaderToTop 0.5s ease-in-out 0s forwards;
        }
        .header-rectangle.loaded {
            animation: fadeInHeaderRectangle 0.5s ease-in-out 0s forwards;
        }
        
        /* Menu più in basso su tablet */
        .bottom-menu {
            bottom: 0;
        }
    }

    @media (max-width: 768px) {
        /* Ottimizzazioni per tablet e mobile - animazione mobile */
        .logo-circle.loaded {
            animation: moveToBottomAndRotateMobile 0.5s ease-in-out 0s forwards !important;
        }
    }
    
    @media (max-width: 576px) {
        body {
            padding: 10px;
            padding-top: 70px;
        }
        .masonry-container {
            gap: 10px;
        }
        .masonry-column {
            gap: 10px;
        }
        
        /* Assicura che le animazioni funzionino anche su mobile */
        .logo-circle {
            animation: rotateLoading 1s ease-in-out infinite;
        }
        .logo-circle.loaded {
            animation: moveToBottomAndRotateMobile 0.5s ease-in-out 0s forwards !important;
        }
        .header {
            top: calc(50% - 100px);
        }
        .header.loaded {
            animation: moveHeaderToTop 0.5s ease-in-out 0s forwards;
        }
        .header-rectangle.loaded {
            animation: fadeInHeaderRectangle 0.5s ease-in-out 0s forwards;
        }
        
        /* Menu più in basso su mobile */
        .bottom-menu {
            bottom: 0;
        }
    }
</style>
</head>
<body>
<header class="header">
    <div class="header-rectangle"></div>
    <div class="header-text">Works</div>
</header>
<div class="logo-circle" id="logo-circle">
    <img src="../../Logo/logo-light.png" alt="Logo">
</div>
<div class="masonry-container"></div>
<div class="bottom-menu" id="bottom-menu">
    <div class="menu-content">
        <a href="../../index.html" class="menu-item">Home</a>
        <a href="#" class="menu-item">Bio</a>
        <a href="#" class="menu-item">Contatti</a>
    </div>
</div>

<footer class="gallery-footer">
    <div class="footer-line"></div>
    <div class="footer-text">Sei arrivato in fondo alla galleria</div>
    <a href="#" class="back-to-top">back to the top</a>
</footer>

<script src="../../scripts/projects.js"></script>
<script>
(function() {
    // Click su "Works" per tornare in cima
    const headerText = document.querySelector('.header-text');
    if (headerText) {
        headerText.addEventListener('click', () => {
            window.scrollTo({ top: 0, behavior: 'smooth' });
        });
    }
    
    const container = document.querySelector('.masonry-container');
    const NUM_COPIES = 5;
    const ANIMATION_BASE_DELAY = 0.5;
    const COLUMN_DELAY = 0.15;
    const ITEM_DELAY = 0.08;
    const LOGO_ANIMATION_DELAY = 1000; // Ridotto per iniziare prima (cerchio finisce a ~1200ms, griglia inizia a 1000ms)
    const IMAGE_PRELOAD_DELAY = 200; // Inizia a pre-caricare le immagini molto prima
    
    // Set per tracciare le immagini già caricate
    const loadedImages = new Set();

    // Funzione per aggiustare i percorsi relativi (da Galleria/Concept/ serve un ../ in più)
    function adjustPath(path) {
        if (!path) return path;
        // Se il percorso inizia con ../, aggiungi un altro ../
        if (path.startsWith('../')) {
            return '../' + path;
        }
        return path;
    }

    function getAllImages() {
        // Combina tutti i progetti (normali e open)
        const allProjects = [...(projects || []), ...(openProjects || [])];
        
        // Raccogli solo le preview dei progetti (limitato a 10)
        // Ogni elemento contiene src e page del progetto
        const allImages = [];
        const maxProjects = 10; // Limita a 10 progetti
        
        allProjects.slice(0, maxProjects).forEach(project => {
            // Aggiungi solo la preview se esiste (aggiustando il percorso)
            if (project.preview) {
                allImages.push({
                    src: adjustPath(project.preview),
                    page: adjustPath(project.page || '')
                });
            }
        });
        
        // Se non ci sono immagini, usa un array vuoto
        if (allImages.length === 0) {
            console.warn('Nessuna immagine trovata nei progetti');
            return [];
        }
        
        // Non duplicare più le immagini, restituisci solo le 10 preview
        return allImages;
    }

    function getResponsiveSettings() {
        const screenWidth = window.innerWidth;
        if (screenWidth <= 576) {
            return {
                numColumns: 2,
                columnWidth: (screenWidth - 30) / 2,
                gap: 10
            };
        } else if (screenWidth <= 992) {
            return {
                numColumns: 2,
                columnWidth: (screenWidth - 45) / 2,
                gap: 15
            };
        } else {
            const numColumns = Math.max(2, Math.min(4, Math.floor((screenWidth - 100) / 320)));
            const gap = 20;
            return {
                numColumns,
                columnWidth: (screenWidth - (numColumns - 1) * gap - 40) / numColumns,
                gap
            };
        }
    }

    function loadImage(imageData, columnWidth) {
        return new Promise((resolve, reject) => {
            const img = new Image();
            img.onload = () => {
                const aspectRatio = img.naturalHeight / img.naturalWidth;
                resolve({
                    src: imageData.src,
                    page: imageData.page,
                    width: columnWidth,
                    height: columnWidth * aspectRatio,
                    aspectRatio
                });
            };
            img.onerror = reject;
            img.src = imageData.src;
        });
    }

    function distributeImages(imageData, numColumns, gap) {
        const columns = Array(numColumns).fill(null).map(() => []);
        const columnHeights = Array(numColumns).fill(0);

        imageData.forEach(data => {
            const colIndex = columnHeights.indexOf(Math.min(...columnHeights));
            columns[colIndex].push(data);
            columnHeights[colIndex] += data.height + (columns[colIndex].length > 1 ? gap : 0);
        });

        return { columns, columnHeights };
    }

    function renderColumns(columns, columnHeights, columnWidth, gap) {
        container.innerHTML = '';
        container.style.gap = gap + 'px';

        const columnDivs = [];
        const allImages = [];

        columns.forEach((column, colIndex) => {
            if (column.length === 0) return;

            const colDiv = document.createElement('div');
            colDiv.className = 'masonry-column';
            colDiv.style.width = columnWidth + 'px';
            colDiv.style.gap = gap + 'px';

            column.forEach((imgData, itemIndex) => {
                const item = document.createElement('div');
                item.className = 'masonry-item';
                item.dataset.columnIndex = colIndex;
                item.dataset.itemIndex = itemIndex;

                // Crea il link se c'è una pagina del progetto
                if (imgData.page) {
                    const link = document.createElement('a');
                    link.href = imgData.page;
                    link.style.display = 'block';
                    link.style.textDecoration = 'none';
                    link.style.width = '100%';

                    const img = document.createElement('img');
                    img.src = imgData.src;
                    img.alt = '';
                    img.loading = 'lazy';
                    img.style.width = '100%';
                    img.style.height = 'auto';
                    img.style.display = 'block';
                    
                    // Traccia se l'immagine è già stata caricata
                    img.dataset.src = imgData.src;
                    if (loadedImages.has(imgData.src)) {
                        item.dataset.alreadyLoaded = 'true';
                    }

                    link.appendChild(img);
                    item.appendChild(link);
                    allImages.push(img);
                } else {
                    // Se non c'è una pagina, crea solo l'immagine
                    const img = document.createElement('img');
                    img.src = imgData.src;
                    img.alt = '';
                    img.loading = 'lazy';
                    img.style.width = '100%';
                    img.style.height = 'auto';
                    img.style.display = 'block';
                    
                    // Traccia se l'immagine è già stata caricata
                    img.dataset.src = imgData.src;
                    if (loadedImages.has(imgData.src)) {
                        item.dataset.alreadyLoaded = 'true';
                    }

                    item.appendChild(img);
                    allImages.push(img);
                }

                colDiv.appendChild(item);
            });

            container.appendChild(colDiv);
            columnDivs.push(colDiv);
        });

        if (allImages.length === 0) return;

        // Avvia le animazioni immediatamente, senza aspettare il caricamento delle immagini
        const allItems = container.querySelectorAll('.masonry-item');
        allItems.forEach(item => {
            // Se l'immagine è già stata caricata, non animarla di nuovo
            if (item.dataset.alreadyLoaded === 'true') {
                item.classList.add('animate');
                return;
            }
            
            const colIndex = parseInt(item.dataset.columnIndex) || 0;
            const itemIndex = parseInt(item.dataset.itemIndex) || 0;
            const delay = (ANIMATION_BASE_DELAY + colIndex * COLUMN_DELAY + itemIndex * ITEM_DELAY) * 1000;
            setTimeout(() => item.classList.add('animate'), delay);
        });

        // Funzione per allineare le colonne (può essere chiamata dopo il caricamento)
        const alignColumns = () => {
            container.offsetHeight;

            const actualHeights = columnDivs.map(colDiv => {
                colDiv.style.paddingBottom = '0';
                return colDiv.offsetHeight;
            });

            const maxHeight = Math.max(...actualHeights);
            columnDivs.forEach((colDiv, index) => {
                const currentHeight = actualHeights[index];
                if (currentHeight < maxHeight && currentHeight > 0) {
                    colDiv.style.paddingBottom = (maxHeight - currentHeight) + 'px';
                }
            });
        };

        // Allinea le colonne dopo un breve delay per permettere al layout di stabilizzarsi
        requestAnimationFrame(() => {
            setTimeout(alignColumns, 100);
        });

        // Allinea nuovamente quando tutte le immagini sono caricate (per correggere eventuali disallineamenti)
        let loadedCount = 0;
        const checkLoaded = () => {
            loadedCount++;
            if (loadedCount === allImages.length) {
                // Aspetta un frame per permettere alle immagini di renderizzarsi
                requestAnimationFrame(() => {
                    setTimeout(alignColumns, 0);
                });
                
                // Mostra il footer dopo che le immagini sono caricate
                const footer = document.querySelector('.gallery-footer');
                if (footer) {
                    footer.classList.add('visible');
                }
            }
        };

        allImages.forEach(img => {
            if (img.complete) {
                // Se l'immagine è già caricata, aggiungila al set
                if (img.dataset.src) {
                    loadedImages.add(img.dataset.src);
                }
                checkLoaded();
            } else {
                img.addEventListener('load', () => {
                    // Aggiungi l'immagine al set quando viene caricata
                    if (img.dataset.src) {
                        loadedImages.add(img.dataset.src);
                    }
                    checkLoaded();
                });
                img.addEventListener('error', checkLoaded);
            }
        });
    }

    async function createMasonryGrid() {
        const images = getAllImages();
        if (images.length === 0) {
            container.innerHTML = '<p style="color: white; text-align: center; padding: 50px;">Nessuna immagine trovata</p>';
            return;
        }

        const { numColumns, columnWidth, gap } = getResponsiveSettings();
        const columns = Array(numColumns).fill(null).map(() => []);
        const columnHeights = Array(numColumns).fill(0);

        try {
            const imagePromises = images.map(imageData => loadImage(imageData, columnWidth));
            const results = await Promise.allSettled(imagePromises);
            const imageData = results
                .filter(result => result.status === 'fulfilled')
                .map(result => result.value);

            if (imageData.length === 0) {
                container.innerHTML = '<p style="color: white; text-align: center; padding: 50px;">Nessuna immagine disponibile</p>';
                return;
            }

            const { columns: distributedColumns, columnHeights: distributedHeights } = distributeImages(imageData, numColumns, gap);
            renderColumns(distributedColumns, distributedHeights, columnWidth, gap);
        } catch (error) {
            console.error('Errore nel caricamento delle immagini:', error);
        }
    }

    // Pre-carica tutte le immagini prima di avviare le animazioni
    function preloadAllImages() {
        return new Promise((resolve) => {
            const images = getAllImages();
            if (images.length === 0) {
                resolve();
                return;
            }
            
            let loadedCount = 0;
            let errorCount = 0;
            const totalImages = images.length;
            
            function checkComplete() {
                if (loadedCount + errorCount >= totalImages) {
                    resolve();
                }
            }
            
            // Carica tutte le immagini in parallelo (ma con un limite per non sovraccaricare)
            const maxConcurrent = 10;
            let currentIndex = 0;
            let activeLoads = 0;
            
            function loadNextBatch() {
                while (activeLoads < maxConcurrent && currentIndex < totalImages) {
                    const imageData = images[currentIndex];
                    currentIndex++;
                    activeLoads++;
                    
                    const img = new Image();
                    img.onload = () => {
                        loadedImages.add(imageData.src);
                        loadedCount++;
                        activeLoads--;
                        checkComplete();
                        if (currentIndex < totalImages) {
                            loadNextBatch();
                        }
                    };
                    img.onerror = () => {
                        errorCount++;
                        activeLoads--;
                        checkComplete();
                        if (currentIndex < totalImages) {
                            loadNextBatch();
                        }
                    };
                    img.src = imageData.src;
                }
            }
            
            // Inizia il caricamento
            loadNextBatch();
        });
    }
    
    // Funzione per aspettare che finisca il ciclo corrente di rotazione
    function waitForRotationCycle() {
        return new Promise((resolve) => {
            // L'animazione dura 1s, aspetta che finisca il ciclo corrente
            // Calcola quando finirà il prossimo ciclo completo
            const animationDuration = 1000; // 1 secondo
            const now = performance.now();
            const elapsed = now % animationDuration;
            const timeUntilNextCycle = animationDuration - elapsed;
            
            // Aspetta che finisca il ciclo corrente (fino al 100% dell'animazione)
            // Aggiungiamo un piccolo buffer per assicurarci che sia completato
            setTimeout(() => {
                resolve();
            }, timeUntilNextCycle + 100);
        });
    }
    
    // Carica tutte le immagini e poi avvia le animazioni
    preloadAllImages().then(() => {
        // Aspetta che finisca l'ultimo ciclo di rotazione completo (360 gradi)
        waitForRotationCycle().then(() => {
            // Quando il ciclo è completato, ferma la rotazione e avvia le animazioni
            const logoCircle = document.getElementById('logo-circle');
            const header = document.querySelector('.header');
            const headerRectangle = document.querySelector('.header-rectangle');
            
            if (logoCircle) {
                // Ferma l'animazione di rotazione
                logoCircle.style.animation = 'none';
                
                // Forza un reflow per applicare il cambio
                void logoCircle.offsetHeight;
                
                // Rimuovi tutti gli stili inline che potrebbero interferire
                logoCircle.style.removeProperty('animation');
                logoCircle.style.removeProperty('animation-name');
                logoCircle.style.removeProperty('animation-duration');
                logoCircle.style.removeProperty('animation-timing-function');
                logoCircle.style.removeProperty('animation-delay');
                logoCircle.style.removeProperty('animation-iteration-count');
                logoCircle.style.removeProperty('animation-direction');
                logoCircle.style.removeProperty('animation-fill-mode');
                
                // Forza un altro reflow
                void logoCircle.offsetHeight;
                
                // Aggiungi la classe loaded che avvierà la nuova animazione
                logoCircle.classList.add('loaded');
                
                // Usa animationend event per essere sicuri che l'animazione sia completata
                const handleAnimationEnd = (e) => {
                    // Supporta sia l'animazione desktop che mobile
                    if (e.animationName === 'moveToBottomAndRotate' || 
                        e.animationName === 'moveToBottomAndRotateMobile' || 
                        logoCircle.classList.contains('loaded')) {
                        // Rimuovi l'event listener dopo l'uso
                        logoCircle.removeEventListener('animationend', handleAnimationEnd);
                        // Assicurati che l'header sia caricato prima di inizializzare la fisica
                        // Questo previene il problema del cerchio che si sposta prima della scritta "Works"
                        const headerLoaded = header && header.classList.contains('loaded');
                        const headerRectLoaded = headerRectangle && headerRectangle.classList.contains('loaded');
                        
                        // Se l'header non è ancora caricato, aspetta
                        if (!headerLoaded || !headerRectLoaded) {
                            const checkHeader = setInterval(() => {
                                const hLoaded = header && header.classList.contains('loaded');
                                const hrLoaded = headerRectangle && headerRectangle.classList.contains('loaded');
                                if (hLoaded && hrLoaded) {
                                    clearInterval(checkHeader);
                                    // Inizializza la fisica del cerchio dopo che l'animazione è completata
                                    const isMobile = window.innerWidth <= 768;
                                    const delay = isMobile ? 100 : 50;
                                    setTimeout(() => {
                                        if (logoCircle && typeof initializeCirclePhysics === 'function') {
                                            initializeCirclePhysics();
                                        }
                                    }, delay);
                                }
                            }, 50);
                            // Timeout di sicurezza dopo 1 secondo
                            setTimeout(() => {
                                clearInterval(checkHeader);
                                if (logoCircle && typeof initializeCirclePhysics === 'function') {
                                    initializeCirclePhysics();
                                }
                            }, 1000);
                        } else {
                            // Inizializza la fisica del cerchio dopo che l'animazione è completata
                            // Su mobile, aspetta un po' di più per assicurarsi che l'animazione sia completamente finita
                            const isMobile = window.innerWidth <= 768;
                            const delay = isMobile ? 100 : 50;
                            setTimeout(() => {
                                if (logoCircle && typeof initializeCirclePhysics === 'function') {
                                    initializeCirclePhysics();
                                }
                            }, delay);
                        }
                    }
                };
                
                logoCircle.addEventListener('animationend', handleAnimationEnd);
                
                // Fallback con timeout nel caso animationend non funzioni
                // Su mobile, aspetta più tempo per l'animazione
                const isMobileDevice = window.innerWidth <= 768;
                const fallbackTimeout = isMobileDevice ? 900 : 700;
                
                setTimeout(() => {
                    if (logoCircle && typeof initializeCirclePhysics === 'function') {
                        // Calcola l'offset corretto per mobile
                        const isMobile = window.innerWidth <= 768;
                        const circleBottomOffset = isMobile ? 80 : CIRCLE_REST_BOTTOM;
                        
                        // Verifica se l'animazione è completata controllando la posizione
                        const pos = getCirclePosition();
                        const expectedBottom = window.innerHeight - circleBottomOffset - CIRCLE_SIZE / 2;
                        const centerThreshold = window.innerHeight / 2;
                        
                        // Tolleranza adattiva (più grande su mobile)
                        const tolerance = Math.max(100, window.innerHeight * 0.15);
                        const isAtBottom = Math.abs(pos.top - expectedBottom) < tolerance;
                        const isAtCenter = Math.abs(pos.top - centerThreshold) < tolerance;
                        
                        if ((!isAtBottom && !isAtCenter) && logoCircle.classList.contains('loaded')) {
                            // Se non è nella posizione corretta ma l'animazione dovrebbe essere finita, forza il posizionamento
                            initializeCirclePhysics();
                        } else if (isAtCenter && !menuOpen && logoCircle.classList.contains('loaded')) {
                            // Se è ancora al centro, correggilo
                            initializeCirclePhysics();
                        }
                    }
                }, fallbackTimeout);
            }
            // Assicurati che l'header sia caricato PRIMA di spostare il cerchio
            // Questo previene il problema del cerchio che si sposta prima della scritta "Works"
            if (header) {
                header.classList.add('loaded');
            }
            if (headerRectangle) {
                headerRectangle.classList.add('loaded');
            }
            
            // Crea la griglia dopo che le animazioni del cerchio e header sono partite
            // Su mobile, ritarda di più per evitare che si carichi troppo presto
            const isMobile = window.innerWidth <= 768;
            const headerAnimationDelay = 500; // Tempo per l'animazione dell'header
            const gridDelay = isMobile ? LOGO_ANIMATION_DELAY + 500 + headerAnimationDelay : LOGO_ANIMATION_DELAY + headerAnimationDelay;
            setTimeout(() => createMasonryGrid(), gridDelay);
        });
    });

    let resizeTimer;
    window.addEventListener('resize', () => {
        clearTimeout(resizeTimer);
        resizeTimer = setTimeout(createMasonryGrid, 250);
    });

    // Back to top functionality
    const backToTopLink = document.querySelector('.back-to-top');
    if (backToTopLink) {
        backToTopLink.addEventListener('click', (e) => {
            e.preventDefault();
            window.scrollTo({ top: 0, behavior: 'smooth' });
        });
    }

    // Menu functionality
    const logoCircle = document.getElementById('logo-circle');
    const bottomMenu = document.getElementById('bottom-menu');
    const MENU_HEIGHT = 400;
    let menuOpen = false;
    
    function toggleMenuFromPosition(circleTop) {
        // Calcola l'offset corretto per mobile
        const isMobile = window.innerWidth <= 768;
        const circleBottomOffset = isMobile ? 80 : CIRCLE_REST_BOTTOM;
        
        // Determina lo stato corrente del menu basandosi sulla posizione del cerchio fornita
        const closedRestTop = window.innerHeight - circleBottomOffset - CIRCLE_SIZE / 2;
        const currentDragUpDistance = closedRestTop - circleTop;
        
        // Se il cerchio è sopra la posizione di riposo, il menu è aperto (almeno parzialmente)
        const isCurrentlyOpen = currentDragUpDistance > MENU_HEIGHT * 0.5;
        
        // Inverti lo stato: se è aperto, chiudilo; se è chiuso, aprilo
        const newMenuOpen = !isCurrentlyOpen;
        
        // Aggiorna la variabile di stato
        menuOpen = newMenuOpen;
        
        // Aggiorna il menu visivamente
        if (bottomMenu) {
            // Rimuovi la classe dragging per permettere la transizione
            bottomMenu.classList.remove('dragging');
            
            // Assicurati che la transizione CSS sia attiva
            bottomMenu.style.transition = 'height 0.2s ease-out';
            
            if (menuOpen) {
                bottomMenu.classList.add('open');
                bottomMenu.style.height = MENU_HEIGHT + 'px';
            } else {
                bottomMenu.classList.remove('open');
                bottomMenu.style.height = '0px';
            }
        }
        
        // Aggiorna la posizione di riposo del cerchio quando il menu si apre/chiude
        updateCircleRestPosition();
        
        // Anima il cerchio alla nuova posizione
        if (!isDragging && logoCircle) {
            // Ferma qualsiasi animazione a molla in corso
            if (springAnimId) {
                cancelAnimationFrame(springAnimId);
                springAnimId = null;
            }
            
            // Rimuovi completamente l'animazione CSS e qualsiasi stile che potrebbe interferire
            logoCircle.style.animation = 'none';
            logoCircle.style.removeProperty('animation');
            logoCircle.style.removeProperty('animation-name');
            logoCircle.style.removeProperty('animation-duration');
            logoCircle.style.removeProperty('animation-timing-function');
            logoCircle.style.removeProperty('animation-delay');
            logoCircle.style.removeProperty('animation-iteration-count');
            logoCircle.style.removeProperty('animation-direction');
            logoCircle.style.removeProperty('animation-fill-mode');
            void logoCircle.offsetHeight; // Forza reflow
            
            // Leggi la posizione corrente PRIMA di impostare la transizione
            const currentPos = getCirclePosition();
            const currentTop = currentPos.top;
            const currentLeft = currentPos.left;
            
            // Imposta la nuova posizione target (assicurati che circleRestTop sia stato aggiornato)
            // Se circleRestTop non è valido, ricalcolalo
            if (!circleRestTop || circleRestTop <= 0) {
                updateCircleRestPosition();
            }
            
            const targetTop = circleRestTop;
            const targetLeft = circleRestLeft || window.innerWidth / 2;
            
            // Se la posizione target è diversa dalla corrente, anima
            if (Math.abs(targetTop - currentTop) > 1 || Math.abs(targetLeft - currentLeft) > 1) {
                // Usa una transizione CSS con la stessa velocità del menu (0.2s ease-out)
                logoCircle.style.transition = 'top 0.2s ease-out, left 0.2s ease-out';
                
                // Imposta direttamente la posizione usando setProperty con !important
                // IMPORTANTE: imposta top PRIMA di left per evitare conflitti
                logoCircle.style.setProperty('top', targetTop + 'px', 'important');
                logoCircle.style.setProperty('left', targetLeft + 'px', 'important');
                logoCircle.style.setProperty('transform', 'translate(-50%, -50%)', 'important');
                
                // Forza un reflow per assicurarsi che le modifiche siano applicate
                void logoCircle.offsetHeight;
                
                // Aggiorna anche circleRestLeft e circleRestTop
                circleRestLeft = targetLeft;
                circleRestTop = targetTop;
                
                // Rimuovi la transizione dopo l'animazione per permettere il drag
                setTimeout(() => {
                    if (logoCircle && !isDragging) {
                        logoCircle.style.transition = '';
                        logoCircle.style.removeProperty('transition');
                    }
                }, 200);
            }
        }
    }
    
    function toggleMenu() {
        // Determina lo stato corrente del menu basandosi sulla posizione REALE del cerchio
        if (!logoCircle) return;
        
        // Leggi la posizione corrente reale del cerchio
        const pos = getCirclePosition();
        const currentTop = pos.top;
        
        // Calcola l'offset corretto per mobile
        const isMobile = window.innerWidth <= 768;
        const circleBottomOffset = isMobile ? 80 : CIRCLE_REST_BOTTOM;
        
        // Determina lo stato corrente del menu basandosi sulla posizione del cerchio
        const closedRestTop = window.innerHeight - circleBottomOffset - CIRCLE_SIZE / 2;
        const currentDragUpDistance = closedRestTop - currentTop;
        
        // Se il cerchio è sopra la posizione di riposo, il menu è aperto (almeno parzialmente)
        const isCurrentlyOpen = currentDragUpDistance > MENU_HEIGHT * 0.5;
        
        // Inverti lo stato: se è aperto, chiudilo; se è chiuso, aprilo
        menuOpen = !isCurrentlyOpen;
        
        // Aggiorna la posizione di riposo del cerchio quando il menu si apre/chiude
        updateCircleRestPosition();
        
        // Anima il cerchio e il menu in sincronia usando requestAnimationFrame
        // per assicurarsi che inizino nello stesso frame
        requestAnimationFrame(() => {
            // Aggiorna il menu visivamente
            if (bottomMenu) {
                // Rimuovi la classe dragging per permettere la transizione
                bottomMenu.classList.remove('dragging');
                
                // Assicurati che la transizione CSS sia attiva
                bottomMenu.style.transition = 'height 0.2s ease-out';
                
                if (menuOpen) {
                    bottomMenu.classList.add('open');
                    bottomMenu.style.height = MENU_HEIGHT + 'px';
                } else {
                    bottomMenu.classList.remove('open');
                    bottomMenu.style.height = '0px';
                }
            }
            
            // Anima il cerchio alla nuova posizione con la stessa velocità del menu
            if (!isDragging && logoCircle) {
            // Ferma qualsiasi animazione a molla in corso
            if (springAnimId) {
                cancelAnimationFrame(springAnimId);
                springAnimId = null;
            }
            
            // Rimuovi completamente l'animazione CSS e qualsiasi stile che potrebbe interferire
            logoCircle.style.animation = 'none';
            logoCircle.style.removeProperty('animation');
            logoCircle.style.removeProperty('animation-name');
            logoCircle.style.removeProperty('animation-duration');
            logoCircle.style.removeProperty('animation-timing-function');
            logoCircle.style.removeProperty('animation-delay');
            logoCircle.style.removeProperty('animation-iteration-count');
            logoCircle.style.removeProperty('animation-direction');
            logoCircle.style.removeProperty('animation-fill-mode');
            void logoCircle.offsetHeight; // Forza reflow
            
            // Leggi la posizione corrente PRIMA di impostare la transizione
            const currentPos = getCirclePosition();
            const currentCircleTop = currentPos.top;
            const currentCircleLeft = currentPos.left;
            
            // Imposta la nuova posizione target
            if (!circleRestTop || circleRestTop <= 0) {
                updateCircleRestPosition();
            }
            
            const targetTop = circleRestTop;
            const targetLeft = circleRestLeft || window.innerWidth / 2;
            
            // Se la posizione target è diversa dalla corrente, anima
            if (Math.abs(targetTop - currentCircleTop) > 1 || Math.abs(targetLeft - currentCircleLeft) > 1) {
                // Usa una transizione CSS con la stessa velocità del menu (0.2s ease-out)
                // Usa requestAnimationFrame per sincronizzare meglio con il menu
                requestAnimationFrame(() => {
                    logoCircle.style.transition = 'top 0.2s ease-out, left 0.2s ease-out';
                    
                    // Imposta direttamente la posizione usando setProperty con !important
                    logoCircle.style.setProperty('top', targetTop + 'px', 'important');
                    logoCircle.style.setProperty('left', targetLeft + 'px', 'important');
                    logoCircle.style.setProperty('transform', 'translate(-50%, -50%)', 'important');
                    
                    // Forza un reflow per assicurarsi che le modifiche siano applicate
                    void logoCircle.offsetHeight;
                });
                
                // Aggiorna anche circleRestLeft e circleRestTop
                circleRestLeft = targetLeft;
                circleRestTop = targetTop;
                
                // Rimuovi la transizione dopo l'animazione per permettere il drag
                setTimeout(() => {
                    if (logoCircle && !isDragging) {
                        logoCircle.style.transition = '';
                        logoCircle.style.removeProperty('transition');
                    }
                }, 200);
            }
            }
        });
    }
    
    function updateCircleRestPosition() {
        // Calcola la nuova posizione di riposo basata sullo stato del menu
        // Su mobile, usa un valore più basso per CIRCLE_REST_BOTTOM
        const isMobile = window.innerWidth <= 768;
        const circleBottomOffset = isMobile ? 80 : CIRCLE_REST_BOTTOM;
        
        if (menuOpen) {
            // Quando il menu è aperto, il cerchio è al centro (come nella home)
            circleRestTop = window.innerHeight / 2;
        } else {
            // Quando il menu è chiuso, posizione normale
            circleRestTop = window.innerHeight - circleBottomOffset - CIRCLE_SIZE / 2;
        }
    }
    
    function updateMenuHeightFromCircle(circleTop) {
        if (!bottomMenu) return;
        
        // Calcola l'offset corretto per mobile
        const isMobile = window.innerWidth <= 768;
        const circleBottomOffset = isMobile ? 80 : CIRCLE_REST_BOTTOM;
        
        // Calcola la posizione di riposo quando il menu è chiuso
        const closedRestTop = window.innerHeight - circleBottomOffset - CIRCLE_SIZE / 2;
        
        // Calcola quanto il cerchio è sopra la posizione di riposo chiusa
        const dragUpDistance = closedRestTop - circleTop;
        
        // Limita l'altezza del menu tra 0 e MENU_HEIGHT basata sulla distanza trascinata verso l'alto
        // Usa Math.max per gestire anche quando il cerchio viene trascinato verso il basso (dragUpDistance negativo)
        const menuHeight = Math.max(0, Math.min(MENU_HEIGHT, dragUpDistance));
        
        // Applica sempre l'altezza calcolata (rimuove qualsiasi altezza fissa precedente)
        bottomMenu.style.height = menuHeight + 'px';
        
        // Aggiorna lo stato del menu in base all'altezza
        const newMenuOpen = menuHeight > MENU_HEIGHT * 0.5;
        
        // Aggiorna la classe solo se lo stato è cambiato
        if (newMenuOpen !== menuOpen) {
            menuOpen = newMenuOpen;
            if (menuOpen) {
                bottomMenu.classList.add('open');
            } else {
                bottomMenu.classList.remove('open');
            }
        }
    }
    

    // Spring physics per il cerchio
    const CIRCLE_REST_BOTTOM = 100;
    const CIRCLE_SIZE = 60;
    let circleRestTop = 0;
    let circleRestLeft = 0;
    let isDragging = false;
    let dragStartX = 0;
    let dragStartY = 0;
    let dragStartLeft = 0;
    let dragStartTop = 0;
    let currentCircleLeft = 0;
    let currentCircleTop = 0;
    let springAnimId = null;
    let hasMoved = false;

    // Imposta posizione cerchio (rimuove animazione CSS e imposta posizione precisa)
    function setCirclePosition(left, top, preserveTransition = false) {
        if (!logoCircle) return;
        // Rimuovi sempre l'animazione CSS quando iniziamo a controllare con JavaScript
        // (le animazioni CSS interferiscono con il controllo JavaScript)
        logoCircle.style.animation = 'none';
        logoCircle.style.removeProperty('animation');
        logoCircle.style.removeProperty('animation-name');
        logoCircle.style.removeProperty('animation-duration');
        logoCircle.style.removeProperty('animation-timing-function');
        logoCircle.style.removeProperty('animation-delay');
        logoCircle.style.removeProperty('animation-iteration-count');
        logoCircle.style.removeProperty('animation-direction');
        logoCircle.style.removeProperty('animation-fill-mode');
        // Ma preserva la transizione se richiesto
        if (!preserveTransition) {
            logoCircle.style.transition = '';
            logoCircle.style.removeProperty('transition');
        }
        // IMPORTANTE: imposta top e left come stili inline con !important per sovrascrivere qualsiasi CSS
        logoCircle.style.setProperty('left', left + 'px', 'important');
        logoCircle.style.setProperty('top', top + 'px', 'important');
        logoCircle.style.setProperty('transform', 'translate(-50%, -50%)', 'important');
        // Forza il reflow per assicurare che le modifiche siano applicate
        void logoCircle.offsetHeight;
    }

    // Leggi la posizione reale del cerchio
    function getCirclePosition() {
        if (!logoCircle) return { left: 0, top: 0 };
        const rect = logoCircle.getBoundingClientRect();
        // Ritorna il centro del cerchio (perché usa translate(-50%, -50%))
        return {
            left: rect.left + rect.width / 2,
            top: rect.top + rect.height / 2
        };
    }

    // Animazione a molla per entrambi gli assi
    function animateSpring(targetLeft, targetTop, startLeft, startTop, velocityX = 0, velocityY = 0) {
        if (springAnimId) {
            cancelAnimationFrame(springAnimId);
        }

        const SPRING = 0.35;
        const DAMPING = 0.75;
        let posX = startLeft;
        let posY = startTop;
        let velX = velocityX;
        let velY = velocityY;

        function step() {
            const distX = targetLeft - posX;
            const distY = targetTop - posY;
            
            const forceX = distX * SPRING;
            const forceY = distY * SPRING;
            const dampingX = velX * DAMPING;
            const dampingY = velY * DAMPING;
            
            const accelX = forceX - dampingX;
            const accelY = forceY - dampingY;

            velX += accelX;
            velY += accelY;
            posX += velX;
            posY += velY;

            setCirclePosition(posX, posY);

            // Condizioni di stop: ferma quando sia X che Y sono stabili
            if (Math.abs(distX) < 0.3 && Math.abs(distY) < 0.3 && 
                Math.abs(velX) < 0.15 && Math.abs(velY) < 0.15) {
                setCirclePosition(targetLeft, targetTop);
                circleRestLeft = targetLeft;
                circleRestTop = targetTop;
                springAnimId = null;
                // Reset hasMoved dopo che l'animazione è completata per permettere i click successivi
                hasMoved = false;
                return;
            }

            springAnimId = requestAnimationFrame(step);
        }

        step();
    }

    // Inizializza dopo animazione CSS
    // Usa animationend event per essere sicuri che l'animazione sia finita
    function initializeCirclePhysics() {
        if (!logoCircle) return;
        
        // Calcola sempre la posizione corretta basandosi sullo stato del menu
        updateCircleRestPosition();
        circleRestLeft = window.innerWidth / 2;
        
        // Calcola l'offset corretto per mobile
        const isMobile = window.innerWidth <= 768;
        const circleBottomOffset = isMobile ? 80 : CIRCLE_REST_BOTTOM;
        
        // Se circleRestTop non è valido, calcolalo di nuovo
        if (!circleRestTop || circleRestTop <= 0) {
            // Menu è chiuso di default all'inizio
            circleRestTop = window.innerHeight - circleBottomOffset - CIRCLE_SIZE / 2;
        }
        
        // Leggi la posizione REALE corrente del cerchio
        const currentPos = getCirclePosition();
        const currentTop = currentPos.top;
        const currentLeft = currentPos.left;
        
        // Calcola la posizione target corretta
        const expectedBottom = window.innerHeight - circleBottomOffset - CIRCLE_SIZE / 2;
        const centerThreshold = window.innerHeight / 2;
        
        // Tolleranza maggiore su mobile (circa 10% dell'altezza dello schermo)
        const tolerance = Math.max(50, window.innerHeight * 0.1);
        const isAtCenter = Math.abs(currentTop - centerThreshold) < tolerance;
        const isAtExpectedBottom = Math.abs(currentTop - expectedBottom) < tolerance;
        
        if (isAtCenter || currentTop <= 0 || (!isAtExpectedBottom && !menuOpen)) {
            // Il cerchio è ancora al centro o in posizione errata, forza il posizionamento corretto
            circleRestTop = expectedBottom;
            circleRestLeft = window.innerWidth / 2;
            
            // Imposta direttamente la posizione corretta senza transizione per essere sicuri
            setCirclePosition(circleRestLeft, circleRestTop);
        } else {
            // Il cerchio è in una posizione valida, usa quella
            circleRestTop = currentTop;
            circleRestLeft = currentLeft;
            setCirclePosition(circleRestLeft, circleRestTop);
        }
        
        // Verifica nuovamente dopo un breve delay per assicurarsi che la posizione sia corretta
        // Su mobile, aspetta un po' di più
        const verifyDelay = isMobile ? 150 : 100;
        setTimeout(() => {
            if (!isDragging && !springAnimId) {
                const verifyPos = getCirclePosition();
                const verifyExpectedBottom = window.innerHeight - circleBottomOffset - CIRCLE_SIZE / 2;
                const verifyCenter = window.innerHeight / 2;
                const verifyTolerance = Math.max(50, window.innerHeight * 0.1);
                
                if (Math.abs(verifyPos.top - verifyCenter) < verifyTolerance && !menuOpen) {
                    // Il cerchio è ancora al centro, correggilo
                    circleRestTop = verifyExpectedBottom;
                    circleRestLeft = window.innerWidth / 2;
                    setCirclePosition(circleRestLeft, circleRestTop);
                }
            }
        }, verifyDelay);

        if (bottomMenu) {

            // Drag con mouse
            let totalDragDistance = 0;
            
            logoCircle.addEventListener('mousedown', (e) => {
                e.preventDefault();
                e.stopPropagation();
                
                // Ferma qualsiasi animazione in corso
                if (springAnimId) {
                    cancelAnimationFrame(springAnimId);
                    springAnimId = null;
                }
                
                // Rimuovi transizione per movimento fluido durante il drag
                logoCircle.style.transition = 'none';
                if (bottomMenu) {
                    bottomMenu.classList.add('dragging');
                }
                
                isDragging = true;
                hasMoved = false;
                totalDragDistance = 0;
                dragStartX = e.clientX;
                dragStartY = e.clientY;
                
                // Leggi la posizione ATTUALE reale del cerchio
                const pos = getCirclePosition();
                dragStartLeft = pos.left;
                dragStartTop = pos.top;
                currentCircleLeft = dragStartLeft;
                currentCircleTop = dragStartTop;
                
                // Aggiorna il menu in base alla posizione iniziale del cerchio
                // Questo assicura che il menu parta dalla posizione corretta quando si inizia un nuovo drag
                updateMenuHeightFromCircle(dragStartTop);
                
                logoCircle.classList.add('dragging');
            });

            document.addEventListener('mousemove', (e) => {
                if (isDragging && logoCircle) {
                    const deltaX = e.clientX - dragStartX;
                    const deltaY = e.clientY - dragStartY;
                    
                    // Calcola la distanza totale del drag
                    totalDragDistance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                    
                    if (Math.abs(deltaX) > 5 || Math.abs(deltaY) > 5) {
                        hasMoved = true;
                    }
                    
                    // Applica rapporto 3/4 al movimento del mouse
                    const moveRatio = 0.75;
                    currentCircleLeft = dragStartLeft + (deltaX * moveRatio);
                    currentCircleTop = dragStartTop + (deltaY * moveRatio);
                    
                    // Limita movimento (opzionale, per evitare che esca dallo schermo)
                    const minLeft = CIRCLE_SIZE / 2;
                    const maxLeft = window.innerWidth - CIRCLE_SIZE / 2;
                    const minTop = CIRCLE_SIZE / 2;
                    const maxTop = window.innerHeight - CIRCLE_SIZE / 2;
                    
                    currentCircleLeft = Math.max(minLeft, Math.min(maxLeft, currentCircleLeft));
                    currentCircleTop = Math.max(minTop, Math.min(maxTop, currentCircleTop));
                    
                    setCirclePosition(currentCircleLeft, currentCircleTop);
                    
                    // Aggiorna sempre l'altezza del menu in base alla posizione del cerchio durante il drag
                    // Il menu deve seguire il cerchio in tempo reale
                    updateMenuHeightFromCircle(currentCircleTop);
                }
            });

            document.addEventListener('mouseup', (e) => {
                if (isDragging) {
                    isDragging = false;
                    logoCircle.classList.remove('dragging');
                    
                    if (bottomMenu) {
                        bottomMenu.classList.remove('dragging');
                    }
                    
                    // Se il drag è minore di 8px, considera come click e apri/chiudi menu
                    if (totalDragDistance < 8) {
                        // Usa toggleMenu() che legge la posizione corrente reale del cerchio
                        toggleMenu();
                        
                        // Reset immediato per permettere click successivi
                        hasMoved = false;
                        totalDragDistance = 0;
                        return;
                    }
                    
                    // Se non è stata ancora impostata, calcolala
                    if (circleRestLeft === 0) {
                        circleRestLeft = window.innerWidth / 2;
                    }
                    
                    // Calcola l'offset corretto per mobile
                    const isMobile = window.innerWidth <= 768;
                    const circleBottomOffset = isMobile ? 80 : CIRCLE_REST_BOTTOM;
                    
                    // Determina l'altezza finale del menu basandosi sulla posizione finale del cerchio
                    const closedRestTop = window.innerHeight - circleBottomOffset - CIRCLE_SIZE / 2;
                    const finalDragUpDistance = closedRestTop - currentCircleTop;
                    const finalMenuHeight = Math.max(0, Math.min(MENU_HEIGHT, finalDragUpDistance));
                    
                    // Se il menu è più della metà aperto, completa l'apertura, altrimenti chiudilo
                    if (finalMenuHeight > MENU_HEIGHT * 0.5) {
                        // Apri completamente
                        menuOpen = true;
                        if (bottomMenu) {
                            bottomMenu.classList.add('open');
                            bottomMenu.style.height = MENU_HEIGHT + 'px';
                        }
                    } else {
                        // Chiudi completamente
                        menuOpen = false;
                        if (bottomMenu) {
                            bottomMenu.classList.remove('open');
                            bottomMenu.style.height = '0px';
                        }
                    }
                    
                    // Aggiorna la posizione di riposo finale
                    updateCircleRestPosition();
                    
                    // Calcola velocità basata sullo spostamento
                    const velocityX = (currentCircleLeft - dragStartLeft) * 0.3;
                    const velocityY = (currentCircleTop - dragStartTop) * 0.3;
                    
                    // Applica fisica a molla
                    animateSpring(circleRestLeft, circleRestTop, currentCircleLeft, currentCircleTop, velocityX, velocityY);
                    
                    // Reset hasMoved dopo un breve delay per permettere click successivi
                    // (verrà resettato anche alla fine dell'animazione a molla)
                    setTimeout(() => {
                        hasMoved = false;
                        totalDragDistance = 0;
                    }, 100);
                }
            });

            // Touch support
            let totalTouchDistance = 0;
            
            logoCircle.addEventListener('touchstart', (e) => {
                e.preventDefault();
                e.stopPropagation();
                
                if (springAnimId) {
                    cancelAnimationFrame(springAnimId);
                    springAnimId = null;
                }
                
                // Rimuovi transizione per movimento fluido durante il drag
                logoCircle.style.transition = 'none';
                if (bottomMenu) {
                    bottomMenu.classList.add('dragging');
                }
                
                isDragging = true;
                hasMoved = false;
                totalTouchDistance = 0;
                dragStartX = e.touches[0].clientX;
                dragStartY = e.touches[0].clientY;
                
                const pos = getCirclePosition();
                dragStartLeft = pos.left;
                dragStartTop = pos.top;
                currentCircleLeft = dragStartLeft;
                currentCircleTop = dragStartTop;
                
                // Aggiorna il menu in base alla posizione iniziale del cerchio
                // Questo assicura che il menu parta dalla posizione corretta quando si inizia un nuovo drag
                updateMenuHeightFromCircle(dragStartTop);
                
                logoCircle.classList.add('dragging');
            }, { passive: false });

            document.addEventListener('touchmove', (e) => {
                if (isDragging && logoCircle) {
                    e.preventDefault();
                    const deltaX = e.touches[0].clientX - dragStartX;
                    const deltaY = e.touches[0].clientY - dragStartY;
                    
                    // Calcola la distanza totale del drag
                    totalTouchDistance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                    
                    if (Math.abs(deltaX) > 5 || Math.abs(deltaY) > 5) {
                        hasMoved = true;
                    }
                    
                    // Applica rapporto 3/4 al movimento del touch
                    const moveRatio = 0.75;
                    currentCircleLeft = dragStartLeft + (deltaX * moveRatio);
                    currentCircleTop = dragStartTop + (deltaY * moveRatio);
                    
                    const minLeft = CIRCLE_SIZE / 2;
                    const maxLeft = window.innerWidth - CIRCLE_SIZE / 2;
                    const minTop = CIRCLE_SIZE / 2;
                    const maxTop = window.innerHeight - CIRCLE_SIZE / 2;
                    
                    currentCircleLeft = Math.max(minLeft, Math.min(maxLeft, currentCircleLeft));
                    currentCircleTop = Math.max(minTop, Math.min(maxTop, currentCircleTop));
                    
                    setCirclePosition(currentCircleLeft, currentCircleTop);
                    
                    // Aggiorna sempre l'altezza del menu in base alla posizione del cerchio durante il drag
                    // Il menu deve seguire il cerchio in tempo reale
                    updateMenuHeightFromCircle(currentCircleTop);
                }
            }, { passive: false });

            document.addEventListener('touchend', (e) => {
                if (isDragging) {
                    isDragging = false;
                    logoCircle.classList.remove('dragging');
                    
                    if (bottomMenu) {
                        bottomMenu.classList.remove('dragging');
                    }
                    
                    // Se il drag è minore di 8px, considera come click e apri/chiudi menu
                    if (totalTouchDistance < 8) {
                        // Usa toggleMenu() che legge la posizione corrente reale del cerchio
                        toggleMenu();
                        
                        // Reset immediato per permettere click successivi
                        hasMoved = false;
                        totalTouchDistance = 0;
                        return;
                    }
                    
                    // Calcola l'offset corretto per mobile
                    const isMobileTouch = window.innerWidth <= 768;
                    const circleBottomOffsetTouch = isMobileTouch ? 80 : CIRCLE_REST_BOTTOM;
                    
                    // Determina l'altezza finale del menu basandosi sulla posizione finale del cerchio
                    const closedRestTop = window.innerHeight - circleBottomOffsetTouch - CIRCLE_SIZE / 2;
                    const finalDragUpDistance = closedRestTop - currentCircleTop;
                    const finalMenuHeight = Math.max(0, Math.min(MENU_HEIGHT, finalDragUpDistance));
                    
                    // Se il menu è più della metà aperto, completa l'apertura, altrimenti chiudilo
                    if (finalMenuHeight > MENU_HEIGHT * 0.5) {
                        // Apri completamente
                        menuOpen = true;
                        if (bottomMenu) {
                            bottomMenu.classList.add('open');
                            bottomMenu.style.height = MENU_HEIGHT + 'px';
                        }
                    } else {
                        // Chiudi completamente
                        menuOpen = false;
                        if (bottomMenu) {
                            bottomMenu.classList.remove('open');
                            bottomMenu.style.height = '0px';
                        }
                    }
                    
                    // Aggiorna la posizione di riposo finale
                    updateCircleRestPosition();
                    
                    if (circleRestLeft === 0) {
                        circleRestLeft = window.innerWidth / 2;
                    }
                    
                    const velocityX = (currentCircleLeft - dragStartLeft) * 0.3;
                    const velocityY = (currentCircleTop - dragStartTop) * 0.3;
                    animateSpring(circleRestLeft, circleRestTop, currentCircleLeft, currentCircleTop, velocityX, velocityY);
                    
                    // Reset hasMoved dopo un breve delay per permettere click successivi
                    // (verrà resettato anche alla fine dell'animazione a molla)
                    setTimeout(() => {
                        hasMoved = false;
                        totalTouchDistance = 0;
                    }, 100);
                }
            });

            // Chiudi menu quando si scrolla
            let scrollTimeout;
            window.addEventListener('scroll', () => {
                if (menuOpen && !isDragging) {
                    clearTimeout(scrollTimeout);
                    scrollTimeout = setTimeout(() => {
                        if (menuOpen) {
                            toggleMenu();
                        }
                    }, 100);
                }
            }, { passive: true });

            // Aggiorna posizione su resize
            window.addEventListener('resize', () => {
                if (!isDragging && !springAnimId) {
                    updateCircleRestPosition();
                    circleRestLeft = window.innerWidth / 2;
                    setCirclePosition(circleRestLeft, circleRestTop);
                }
            });
        }
    }
    
    // Verifica periodica della posizione del cerchio per correggere eventuali problemi
    function verifyCirclePosition() {
        if (!logoCircle || isDragging || springAnimId) return;
        
        const pos = getCirclePosition();
        // Calcola l'offset corretto per mobile
        const isMobile = window.innerWidth <= 768;
        const circleBottomOffset = isMobile ? 80 : CIRCLE_REST_BOTTOM;
        const expectedBottom = window.innerHeight - circleBottomOffset - CIRCLE_SIZE / 2;
        const centerThreshold = window.innerHeight / 2;
        
        // Tolleranza adattiva basata sull'altezza dello schermo (più tolleranza su mobile)
        const tolerance = Math.max(50, window.innerHeight * 0.1);
        const isAtCenter = Math.abs(pos.top - centerThreshold) < tolerance;
        const isAtExpectedBottom = Math.abs(pos.top - expectedBottom) < tolerance;
        
        // Se il menu è chiuso e il cerchio non è nella posizione corretta, correggilo
        if (!menuOpen && !isAtExpectedBottom && !isAtCenter) {
            // Il cerchio potrebbe essere in una posizione intermedia, forzalo nella posizione corretta
            updateCircleRestPosition();
            circleRestLeft = window.innerWidth / 2;
            setCirclePosition(circleRestLeft, circleRestTop);
        } else if (!menuOpen && isAtCenter) {
            // Il cerchio è ancora al centro quando dovrebbe essere in basso, correggilo
            circleRestTop = expectedBottom;
            circleRestLeft = window.innerWidth / 2;
            setCirclePosition(circleRestLeft, circleRestTop);
        }
    }
    
    // Verifica la posizione periodicamente (ogni secondo) dopo che la pagina è caricata
    // Su mobile, verifica più spesso inizialmente
    const isMobile = window.innerWidth <= 768;
    const initialDelay = isMobile ? 1500 : 2000;
    const checkInterval = isMobile ? 500 : 1000;
    
    setTimeout(() => {
        // Verifica immediata dopo il delay iniziale
        verifyCirclePosition();
        // Poi verifica periodicamente
        setInterval(verifyCirclePosition, checkInterval);
    }, initialDelay);
    
    // Inizializza quando l'animazione CSS è completata
    // NOTA: initializeCirclePhysics viene chiamata dopo che l'animazione moveToBottomAndRotate è completata
    // nel codice sopra, quindi non serve chiamarla qui se il cerchio ha la classe loaded
    if (logoCircle) {
        // Usa animationend event se disponibile come fallback aggiuntivo
        logoCircle.addEventListener('animationend', (e) => {
            // Supporta sia l'animazione desktop che mobile
            if (e.animationName === 'moveToBottomAndRotate' || 
                e.animationName === 'moveToBottomAndRotateMobile' || 
                logoCircle.classList.contains('loaded')) {
                // Verifica la posizione dopo l'animazione
                // Su mobile, aspetta un po' di più
                const isMobile = window.innerWidth <= 768;
                const delay = isMobile ? 150 : 100;
                setTimeout(() => {
                    verifyCirclePosition();
                }, delay);
                return;
            }
            // Altrimenti inizializza normalmente (per l'animazione iniziale)
            if (!logoCircle.classList.contains('loaded')) {
                initializeCirclePhysics();
            }
        }, { once: false });
        
        // Fallback con timeout nel caso animationend non funzioni
        // Solo se non è già loaded (altrimenti viene gestito nel codice sopra)
        // Su mobile, aspetta più tempo
        const isMobileDeviceFallback = window.innerWidth <= 768;
        const fallbackDelay = isMobileDeviceFallback ? 2000 : 1500;
        
        setTimeout(() => {
            if (!logoCircle.classList.contains('loaded')) {
                initializeCirclePhysics();
            } else {
                // Se è già loaded, verifica comunque la posizione
                verifyCirclePosition();
                // Forza un'inizializzazione se necessario
                setTimeout(() => {
                    if (!isDragging && !springAnimId) {
                        const pos = getCirclePosition();
                        // Calcola l'offset corretto per mobile
                        const isMobile = window.innerWidth <= 768;
                        const circleBottomOffset = isMobile ? 80 : CIRCLE_REST_BOTTOM;
                        const expectedBottom = window.innerHeight - circleBottomOffset - CIRCLE_SIZE / 2;
                        const centerThreshold = window.innerHeight / 2;
                        const tolerance = Math.max(50, window.innerHeight * 0.1);
                        
                        if (Math.abs(pos.top - centerThreshold) < tolerance && !menuOpen) {
                            initializeCirclePhysics();
                        }
                    }
                }, 200);
            }
        }, fallbackDelay);
    }
    // Reset della selezione del menu quando si torna indietro con le frecce
    // Questo risolve il problema della scritta dell'ultima scelta ancora selezionata
    window.addEventListener('popstate', () => {
        // Piccolo delay per permettere al browser di navigare
        setTimeout(() => {
            // Se siamo sulla pagina masonry-grid, resetta la selezione
            const activeLink = sessionStorage.getItem('activeMenuLink');
            if (activeLink) {
                // Rimuovi la selezione attiva
                sessionStorage.removeItem('activeMenuLink');
                // Rimuovi la classe active da tutti i menu items
                document.querySelectorAll('.menu-item').forEach(item => {
                    item.classList.remove('active');
                });
            }
        }, 0);
    });
    
    // Reset anche quando la pagina viene mostrata (per gestire il caso di navigazione)
    window.addEventListener('pageshow', (e) => {
        // Se la pagina è stata caricata dalla cache (back/forward), resetta la selezione
        if (e.persisted) {
            const activeLink = sessionStorage.getItem('activeMenuLink');
            if (activeLink) {
                sessionStorage.removeItem('activeMenuLink');
                document.querySelectorAll('.menu-item').forEach(item => {
                    item.classList.remove('active');
                });
            }
        }
    });
})();
</script>
</body>
</html>
