<!DOCTYPE html>
<html lang="it">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Works</title>
<link rel="icon" type="image/png" href="../../Logo/logo-light.png" media="(prefers-color-scheme: light)">
<link rel="icon" type="image/png" href="../../Logo/logo-dark.png" media="(prefers-color-scheme: dark)">
<style>
    @font-face {
        font-family: 'PPKyoto';
        src: url('../../Fonts/PPKyoto-MediumItalic.otf') format('opentype');
        font-weight: normal;
        font-style: italic;
    }

    @font-face {
        font-family: 'PPKyoto';
        src: url('../../Fonts/PPKyoto-Medium.otf') format('opentype');
        font-weight: normal;
        font-style: normal;
    }

    @font-face {
        font-family: 'PPNeueMontreal';
        src: url('../../Fonts/PPNeueMontreal-Book.woff2') format('woff2'),
             url('../../Fonts/PPNeueMontreal-Book.woff') format('woff');
        font-weight: normal;
        font-style: normal;
    }

    * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
    }

    body {
        background-color: #000000;
        padding: 20px;
        padding-top: 140px;
    }

    .header {
        position: fixed;
        top: calc(50% - 100px);
        left: 0;
        right: 0;
        height: 70px;
        z-index: 999;
        display: flex;
        align-items: center;
        justify-content: center;
        background-color: #000000;
    }

    .header.loaded {
        animation: moveHeaderToTop 0.5s ease-in-out 0s forwards;
    }

    .tag-filter-section {
        position: fixed;
        top: 70px;
        left: 0;
        right: 0;
        z-index: 998;
        background-color: #000000;
        height: 35px;
        padding: 0 20px;
        display: flex;
        align-items: center;
        gap: 15px;
        opacity: 0;
        transform: translateX(-100%);
        transition: opacity 0.5s ease-in, transform 0.5s ease-in-out;
    }

    .tag-filter-section::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        height: 1.5px;
        background-color: #ffffff;
        z-index: 999;
        pointer-events: none;
    }

    .tag-filter-section.visible {
        opacity: 1;
    }

    .tag-filter-section.loaded {
        animation: slideInFromLeft 0.6s ease-out forwards;
    }

    @keyframes slideInFromLeft {
        from {
            opacity: 0;
            transform: translateX(-100%);
        }
        to {
            opacity: 1;
            transform: translateX(0);
        }
    }

    .year-filter-section {
        position: fixed;
        top: 105px;
        left: 0;
        right: 0;
        z-index: 998;
        background-color: #000000;
        height: 35px;
        padding: 0 20px;
        display: flex;
        align-items: center;
        gap: 15px;
        opacity: 0;
        transform: translateX(-100%);
        transition: opacity 0.5s ease-in, transform 0.5s ease-in-out;
    }

    .year-filter-section::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        height: 1.5px;        background-color: #ffffff;
        z-index: 999;
        pointer-events: none;
    }

    .year-filter-section::after {
        content: '';
        position: absolute;
        bottom: 0;
        left: 0;
        right: 0;
        height: 2px;
        background-color: #ffffff;
        z-index: 999;
        pointer-events: none;
    }

    .year-filter-section.visible {
        opacity: 1;
    }

    .year-filter-section.loaded {
        animation: slideInFromLeft 0.6s ease-out 0.1s forwards;
    }

    .year-label {
        color: white;
        font-family: 'PPNeueMontreal', sans-serif;
        font-size: 18px;
        white-space: nowrap;
        position: absolute;
        left: 20px;
        z-index: 1000;
        pointer-events: none;
    }

    .year-container {
        display: flex;
        flex-wrap: nowrap;
        gap: 0;
        align-items: center;
        overflow-x: auto;
        overflow-y: hidden;
        flex: 1;
        margin-left: 70px;
        scrollbar-width: none;
        -ms-overflow-style: none;
        -webkit-overflow-scrolling: touch;
    }

    .year-container::-webkit-scrollbar {
        display: none;
    }

    .year-button {
        height: 35px;
        padding: 0 18px;
        background-color: #000000;
        color: #ffffff;
        border: none;
        font-family: 'PPNeueMontreal', sans-serif;
        font-size: 16px;
        cursor: pointer;
        position: relative;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: background-color 0.3s ease, color 0.3s ease;
        border-bottom: 1px solid transparent;
        white-space: nowrap;
        flex-shrink: 0;
    }

    .year-button::after {
        content: '';
        position: absolute;
        bottom: -1px;
        left: 0;
        right: 0;
        height: 1px;
        background-color: #ffffff;
        opacity: 0;
        transition: opacity 0.3s ease;
    }

    .year-button:hover::after {
        opacity: 1;
    }

    .year-button.selected {
        background-color: #ffffff;
        color: #000000;
    }

    .year-button.selected::after {
        opacity: 1;
        background-color: #000000;
    }

    .tag-label {
        color: white;
        font-family: 'PPNeueMontreal', sans-serif;
        font-size: 18px;
        white-space: nowrap;
        position: absolute;
        left: 20px;
        z-index: 1000;
        pointer-events: none;
    }

    .tag-container {
        display: flex;
        flex-wrap: nowrap;
        gap: 0;
        align-items: center;
        overflow-x: auto;
        overflow-y: hidden;
        flex: 1;
        margin-left: 70px;
        scrollbar-width: none;
        -ms-overflow-style: none;
        -webkit-overflow-scrolling: touch;
    }

    .tag-container::-webkit-scrollbar {
        display: none;
    }


    .tag-button {
        height: 35px;
        padding: 0 18px;
        background-color: #000000;
        color: #ffffff;
        border: none;
        font-family: 'PPNeueMontreal', sans-serif;
        font-size: 16px;
        cursor: pointer;
        position: relative;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: background-color 0.3s ease, color 0.3s ease;
        border-bottom: 1px solid transparent;
        white-space: nowrap;
        flex-shrink: 0;
    }

    .tag-button::after {
        content: '';
        position: absolute;
        bottom: -1px;
        left: 0;
        right: 0;
        height: 1px;
        background-color: #ffffff;
        opacity: 0;
        transition: opacity 0.3s ease;
    }

    .tag-button:hover::after {
        opacity: 1;
    }

    .tag-button.selected {
        background-color: #ffffff;
        color: #000000;
    }

    .tag-button.selected::after {
        opacity: 1;
        background-color: #000000;
    }

    .header-rectangle {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        height: 70px;
        background-color: #000000;
        opacity: 0;
    }

    .header-rectangle.loaded {
        animation: fadeInHeaderRectangle 0.5s ease-in-out 0s forwards;
    }

    .header-text {
        position: relative;
        z-index: 1000;
        color: white;
        font-size: 48px;
        font-family: 'PPKyoto', sans-serif;
        font-style: italic;
        cursor: pointer;
        transition: opacity 0.3s ease;
        text-decoration: underline;
        text-underline-offset: 2px;
    }

    .header-text:hover {
        opacity: 0.7;
    }

    .logo-circle {
        position: fixed;
        top: 50%;
        left: 50%;
        width: 60px;
        height: 60px;
        transform: translate(-50%, -50%);
        background-color: white;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 1000;
        cursor: pointer;
        animation: rotateLoading 1s ease-in-out infinite;
    }

    .logo-circle.loaded {
        animation: moveToBottomAndRotate 0.5s ease-in-out 0s forwards !important;
    }

    .logo-circle.dragging {
        transition: none;
    }

    .logo-circle img {
        width: 95%;
        height: 95%;
        object-fit: contain;
        display: block;
    }

    .masonry-container {
        display: flex;
        gap: 20px;
        justify-content: center;
    }

    .masonry-column {
        display: flex;
        flex-direction: column;
        gap: 20px;
        flex: 0 0 auto;
    }

    .masonry-item {
        width: 100%;
        opacity: 0;
        transform: translateX(-30px);
    }

    .masonry-item.animate {
        animation: fadeInFromLeft 0.6s ease-out forwards;
    }

    .masonry-item img {
        width: 100%;
        height: auto;
        display: block;
    }

    .masonry-item a {
        display: block;
        width: 100%;
        text-decoration: none;
        cursor: pointer;
        transition: opacity 0.3s ease;
    }

    .masonry-item a:hover {
        opacity: 0.8;
    }

    .gallery-footer {
        margin-top: 40px;
        padding: 20px;
        padding-bottom: 100px;
        text-align: center;
        opacity: 0;
        transition: opacity 0.5s ease-in;
    }

    .gallery-footer.visible {
        opacity: 1;
    }

    .footer-line {
        width: 100%;
        height: 3px;
        background-color: white;
        margin-bottom: 30px;
    }

    .footer-text {
        color: white;
        font-family: sans-serif;
        font-size: 18px;
        margin-bottom: 15px;
        line-height: 1.5;
    }

    .back-to-top {
        color: white;
        font-family: sans-serif;
        font-size: 16px;
        text-decoration: none;
        cursor: pointer;
        display: inline-block;
        transition: opacity 0.3s ease;
    }

    .back-to-top:hover {
        opacity: 0.7;
    }

    .bottom-menu {
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
        background-color: #000000;
        height: 0;
        z-index: 998;
        overflow: hidden;
        transition: height 0.2s ease-out, opacity 0.5s ease-out;
        opacity: 1;
    }

    .bottom-menu::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        height: 2px;
        background-color: #ffffff;
        z-index: 999;
        pointer-events: none;
    }

    .bottom-menu.fade-out {
        opacity: 0;
        pointer-events: none;
    }

    .bottom-menu.open {
        height: 400px;
    }
    
    .bottom-menu.dragging {
        transition: none;
    }

    .menu-content {
        padding: 30px 20px 40px 20px;
        display: flex;
        flex-direction: column;
        gap: 10px;
        align-items: center;
        justify-content: flex-start;
        max-width: 1200px;
        margin: 0 auto;
        height: 100%;
    }

    .menu-item {
        color: white;
        font-family: 'PPKyoto', sans-serif;
        font-size: 48px;
        font-style: italic;
        text-decoration: none;
        cursor: pointer;
        transition: text-decoration 0.3s ease;
        text-align: center;
    }

    .menu-item:hover {
        text-decoration: underline;
        text-underline-offset: 2px;
    }

    .menu-item.active {
        text-decoration: underline;
        text-underline-offset: 2px;
    }

    @keyframes fadeInFromTop {
        from {
            opacity: 0;
            transform: translateY(-20px);
        }
        to {
            opacity: 1;
            transform: translateY(0);
        }
    }

    @keyframes moveHeaderToTop {
        from {
            top: calc(50% - 100px);
        }
        to {
            top: 0;
        }
    }

    @keyframes fadeInHeaderRectangle {
        from {
            opacity: 0;
        }
        to {
            opacity: 1;
        }
    }

    @keyframes typewriter {
        from {
            width: 0;
        }
        to {
            width: 100%;
        }
    }


    @keyframes rotateLoading {
        0% {
            transform: translate(-50%, -50%) rotate(0deg);
        }
        80% {
            transform: translate(-50%, -50%) rotate(360deg);
        }
        100% {
            transform: translate(-50%, -50%) rotate(360deg);
        }
    }

    @keyframes moveToBottomAndRotate {
        from {
            top: 50%;
            transform: translate(-50%, -50%) ;
        }
        to {
            top: calc(100vh - 130px);
            transform: translate(-50%, -50%);
        }
    }
    
    /* Animazione ottimizzata per mobile */
    @keyframes moveToBottomAndRotateMobile {
        from {
            top: 50%;
            transform: translate(-50%, -50%);
        }
        to {
            top: calc(100vh - 110px);
            transform: translate(-50%, -50%);
        }
    }

    @keyframes fadeInFromLeft {
        from {
            opacity: 0;
            transform: translateX(-30px);
        }
        to {
            opacity: 1;
            transform: translateX(0);
        }
    }

    @media (max-width: 992px) {
        body {
            padding: 15px;
            padding-top: 140px;
        }
        .masonry-container {
            gap: 15px;
        }
        .masonry-column {
            gap: 15px;
        }
        
        /* Assicura che le animazioni funzionino anche su tablet */
        .logo-circle {
            animation: rotateLoading 1s ease-in-out infinite;
        }
        .logo-circle.loaded {
            animation: moveToBottomAndRotate 0.5s ease-in-out 0s forwards !important;
        }
        .header {
            top: calc(50% - 100px);
        }
        .header.loaded {
            animation: moveHeaderToTop 0.5s ease-in-out 0s forwards;
        }
        .header-rectangle.loaded {
            animation: fadeInHeaderRectangle 0.5s ease-in-out 0s forwards;
        }
        
        /* Menu più in basso su tablet */
        .bottom-menu {
            bottom: 0;
        }
    }

    @media (max-width: 768px) {
        /* Ottimizzazioni per tablet e mobile - animazione mobile */
        .logo-circle.loaded {
            animation: moveToBottomAndRotateMobile 0.5s ease-in-out 0s forwards !important;
        }
    }
    
    @media (max-width: 576px) {
        body {
            padding: 10px;
            padding-top: 140px;
        }
        .masonry-container {
            gap: 10px;
        }
        .masonry-column {
            gap: 10px;
        }
        
        /* Assicura che le animazioni funzionino anche su mobile */
        .logo-circle {
            animation: rotateLoading 1s ease-in-out infinite;
        }
        .logo-circle.loaded {
            animation: moveToBottomAndRotateMobile 0.5s ease-in-out 0s forwards !important;
        }
        .header {
            top: calc(50% - 100px);
        }
        .header.loaded {
            animation: moveHeaderToTop 0.5s ease-in-out 0s forwards;
        }
        .header-rectangle.loaded {
            animation: fadeInHeaderRectangle 0.5s ease-in-out 0s forwards;
        }
        
        /* Menu più in basso su mobile */
        .bottom-menu {
            bottom: 0;
        }
    }
</style>
</head>
<body>
<header class="header">
    <div class="header-rectangle"></div>
    <div class="header-text">Works</div>
</header>
<div class="tag-filter-section" id="tag-filter-section">
    <span class="tag-label">TAG:</span>
    <div class="tag-container" id="tag-container"></div>
</div>
<div class="year-filter-section" id="year-filter-section">
    <span class="year-label">ANNO:</span>
    <div class="year-container" id="year-container"></div>
</div>
<div class="logo-circle" id="logo-circle">
    <img src="../../Logo/logo-light.png" alt="Logo">
</div>
<div class="masonry-container"></div>
<div class="bottom-menu" id="bottom-menu">
    <div class="menu-content">
        <a href="../../index.html" class="menu-item">Home</a>
        <a href="#" class="menu-item">Bio</a>
        <a href="#" class="menu-item">Contatti</a>
    </div>
</div>

<footer class="gallery-footer">
    <div class="footer-line"></div>
    <div class="footer-text">Sei arrivato in fondo alla galleria</div>
    <a href="#" class="back-to-top">back to the top</a>
</footer>

<script src="../../scripts/projects.js"></script>
<script>
(function() {
    // Click su "Works" per tornare in cima
    const headerText = document.querySelector('.header-text');
    if (headerText) {
        headerText.addEventListener('click', () => {
            window.scrollTo({ top: 0, behavior: 'smooth' });
        });
    }
    
    const container = document.querySelector('.masonry-container');
    const NUM_COPIES = 5;
    const ANIMATION_BASE_DELAY = 0.5;
    const COLUMN_DELAY = 0.15;
    const ITEM_DELAY = 0.08;
    const LOGO_ANIMATION_DELAY = 1000; // Ridotto per iniziare prima (cerchio finisce a ~1200ms, griglia inizia a 1000ms)
    const IMAGE_PRELOAD_DELAY = 200; // Inizia a pre-caricare le immagini molto prima
    
    // Set per tracciare le immagini già caricate
    const loadedImages = new Set();
    
    // Flag per evitare ricreazioni multiple della griglia
    let isCreatingGrid = false;

    // Sistema di filtraggio per tag
    let selectedTags = new Set();
    let allProjectsData = [];
    const tagFilterSection = document.getElementById('tag-filter-section');
    const tagContainer = document.getElementById('tag-container');
    
    // Sistema di filtraggio per anno
    let selectedYears = new Set();
    const yearFilterSection = document.getElementById('year-filter-section');
    const yearContainer = document.getElementById('year-container');
    
    // Variabili per l'animazione automatica dei tag
    let autoScrollAnimation = null;
    let isAutoScrollPaused = false;
    let autoScrollSpeed = 0.2; // pixel per frame (ridotto per scorrimento più lento)
    let scrollAccumulator = 0; // Accumulatore per valori decimali
    
    // Variabili per l'animazione automatica degli anni
    let autoScrollYearAnimation = null;
    let isAutoScrollYearPaused = false;
    let autoScrollYearSpeed = 0.2; // pixel per frame
    let scrollYearAccumulator = 0; // Accumulatore per valori decimali

    // Funzione per estrarre tutti i tag unici dai progetti
    function getAllUniqueTags() {
        const allProjects = [...(projects || []), ...(openProjects || [])];
        const tagsSet = new Set();
        allProjects.forEach(project => {
            if (project.tags && Array.isArray(project.tags)) {
                project.tags.forEach(tag => tagsSet.add(tag));
            }
        });
        return Array.from(tagsSet).sort();
    }

    // Funzione per estrarre tutti gli anni unici dai progetti
    function getAllUniqueYears() {
        const allProjects = [...(projects || []), ...(openProjects || [])];
        const yearsSet = new Set();
        allProjects.forEach(project => {
            if (project.startDate) {
                yearsSet.add(project.startDate);
            }
        });
        return Array.from(yearsSet).sort((a, b) => b.localeCompare(a)); // Ordine decrescente (più recenti prima)
    }

    // Funzione per creare i pulsanti anno
    function createYearButtons() {
        const uniqueYears = getAllUniqueYears();
        yearContainer.innerHTML = '';
        
        uniqueYears.forEach(year => {
            const button = document.createElement('button');
            button.className = 'year-button';
            button.textContent = year;
            button.dataset.year = year;
            button.addEventListener('click', () => toggleYear(year));
            yearContainer.appendChild(button);
        });
        
        // Inizializza il drag e lo scroll con la rotella per gli anni
        initYearContainerScroll();
        
        // Avvia l'animazione automatica (il delay di 2 secondi è gestito all'interno della funzione)
        startAutoScrollYear();
    }

    // Funzione per selezionare/deselezionare un anno
    function toggleYear(year) {
        if (selectedYears.has(year)) {
            selectedYears.delete(year);
        } else {
            selectedYears.add(year);
        }
        
        // Aggiorna lo stato visivo dei pulsanti
        const buttons = yearContainer.querySelectorAll('.year-button');
        buttons.forEach(button => {
            if (selectedYears.has(button.dataset.year)) {
                button.classList.add('selected');
            } else {
                button.classList.remove('selected');
            }
        });
        
        // Metti in pausa l'animazione quando si seleziona un anno
        pauseAutoScrollYear();
        
        // Filtra i progetti
        filterProjects();
    }

    // Funzione per creare i pulsanti tag
    function createTagButtons() {
        const uniqueTags = getAllUniqueTags();
        tagContainer.innerHTML = '';
        
        uniqueTags.forEach(tag => {
            const button = document.createElement('button');
            button.className = 'tag-button';
            button.textContent = tag;
            button.dataset.tag = tag;
            button.addEventListener('click', () => toggleTag(tag));
            tagContainer.appendChild(button);
        });
        
        // Inizializza il drag e lo scroll con la rotella
        initTagContainerScroll();
        
        // Avvia l'animazione automatica (il delay di 2 secondi è gestito all'interno della funzione)
        startAutoScroll();
    }

    // Funzione per controllare se c'è contenuto scrollabile (tag)
    function hasScrollableContent() {
        if (!tagContainer) return false;
        const maxScroll = tagContainer.scrollWidth - tagContainer.clientWidth;
        return maxScroll > 1; // Tolleranza di 1px per evitare problemi di arrotondamento
    }

    // Funzione per controllare se c'è contenuto scrollabile (anni)
    function hasScrollableContentYear() {
        if (!yearContainer) return false;
        const maxScroll = yearContainer.scrollWidth - yearContainer.clientWidth;
        return maxScroll > 1; // Tolleranza di 1px per evitare problemi di arrotondamento
    }

    // Funzione per avviare l'animazione automatica di scroll
    function startAutoScroll() {
        if (!tagContainer) return;
        
        // Controlla se c'è contenuto scrollabile prima di avviare
        if (!hasScrollableContent()) {
            // Se non c'è contenuto scrollabile, ferma l'animazione se è attiva
            if (autoScrollAnimation) {
                cancelAnimationFrame(autoScrollAnimation);
                autoScrollAnimation = null;
            }
            return;
        }
        
        // Ferma l'animazione precedente se esiste
        if (autoScrollAnimation) {
            cancelAnimationFrame(autoScrollAnimation);
            autoScrollAnimation = null;
        }
        
        // Reset dell'accumulatore quando si riavvia l'animazione
        scrollAccumulator = 0;
        
        function animate() {
            // Controlla se l'animazione è in pausa
            if (isAutoScrollPaused) {
                autoScrollAnimation = requestAnimationFrame(animate);
                return;
            }
            
            // Calcola la larghezza scrollabile
            const maxScroll = tagContainer.scrollWidth - tagContainer.clientWidth;
            
            // Se non c'è più contenuto scrollabile (finestra ridimensionata), ferma l'animazione
            if (maxScroll <= 1) {
                autoScrollAnimation = null;
                return;
            }
            
            // Se siamo arrivati in fondo, ricomincia dall'inizio
            if (tagContainer.scrollLeft >= maxScroll - 1) {
                tagContainer.scrollLeft = 0;
                scrollAccumulator = 0; // Reset dell'accumulatore quando si ricomincia
            } else {
                // Aggiungi la velocità all'accumulatore
                scrollAccumulator += autoScrollSpeed;
                
                // Se l'accumulatore ha raggiunto almeno 1 pixel, applica lo scroll
                if (scrollAccumulator >= 1) {
                    const pixelsToScroll = Math.floor(scrollAccumulator);
                    tagContainer.scrollLeft += pixelsToScroll;
                    scrollAccumulator -= pixelsToScroll; // Mantieni la parte decimale
                }
            }
            
            autoScrollAnimation = requestAnimationFrame(animate);
        }
        
        // Avvia l'animazione dopo 2 secondi (stesso delay degli anni)
        setTimeout(() => {
            animate();
        }, 2000);
    }

    // Funzione per mettere in pausa l'animazione per 5 secondi (tag)
    function pauseAutoScroll() {
        isAutoScrollPaused = true;
        setTimeout(() => {
            isAutoScrollPaused = false;
        }, 5000);
    }

    // Funzione per avviare l'animazione automatica di scroll degli anni
    function startAutoScrollYear() {
        if (!yearContainer) return;
        
        // Controlla se c'è contenuto scrollabile prima di avviare
        if (!hasScrollableContentYear()) {
            // Se non c'è contenuto scrollabile, ferma l'animazione se è attiva
            if (autoScrollYearAnimation) {
                cancelAnimationFrame(autoScrollYearAnimation);
                autoScrollYearAnimation = null;
            }
            return;
        }
        
        // Ferma l'animazione precedente se esiste
        if (autoScrollYearAnimation) {
            cancelAnimationFrame(autoScrollYearAnimation);
            autoScrollYearAnimation = null;
        }
        
        // Reset dell'accumulatore quando si riavvia l'animazione
        scrollYearAccumulator = 0;
        
        function animate() {
            // Controlla se l'animazione è in pausa
            if (isAutoScrollYearPaused) {
                autoScrollYearAnimation = requestAnimationFrame(animate);
                return;
            }
            
            // Calcola la larghezza scrollabile
            const maxScroll = yearContainer.scrollWidth - yearContainer.clientWidth;
            
            // Se non c'è più contenuto scrollabile (finestra ridimensionata), ferma l'animazione
            if (maxScroll <= 1) {
                autoScrollYearAnimation = null;
                return;
            }
            
            // Se siamo arrivati in fondo, ricomincia dall'inizio
            if (yearContainer.scrollLeft >= maxScroll - 1) {
                yearContainer.scrollLeft = 0;
                scrollYearAccumulator = 0; // Reset dell'accumulatore quando si ricomincia
            } else {
                // Aggiungi la velocità all'accumulatore
                scrollYearAccumulator += autoScrollYearSpeed;
                
                // Se l'accumulatore ha raggiunto almeno 1 pixel, applica lo scroll
                if (scrollYearAccumulator >= 1) {
                    const pixelsToScroll = Math.floor(scrollYearAccumulator);
                    yearContainer.scrollLeft += pixelsToScroll;
                    scrollYearAccumulator -= pixelsToScroll; // Mantieni la parte decimale
                }
            }
            
            autoScrollYearAnimation = requestAnimationFrame(animate);
        }
        
        // Avvia l'animazione dopo 2 secondi (stesso delay dei tag)
        setTimeout(() => {
            animate();
        }, 2000);
    }

    // Funzione per mettere in pausa l'animazione per 5 secondi (anni)
    function pauseAutoScrollYear() {
        isAutoScrollYearPaused = true;
        setTimeout(() => {
            isAutoScrollYearPaused = false;
        }, 5000);
    }

    // Funzione per inizializzare il drag e lo scroll con la rotella
    function initTagContainerScroll() {
        if (!tagContainer) return;
        
        let isDragging = false;
        let startX = 0;
        let scrollLeft = 0;
        let hasMoved = false;
        let dragThreshold = 5; // Soglia minima per considerare un movimento come drag
        let clickedButton = null;

        // Drag con mouse - permette il drag anche quando si clicca su un tag
        tagContainer.addEventListener('mousedown', (e) => {
            // Salva quale button è stato cliccato (se presente)
            if (e.target.classList.contains('tag-button')) {
                clickedButton = e.target;
            } else {
                clickedButton = null;
            }
            
            isDragging = true;
            hasMoved = false;
            tagContainer.style.cursor = 'grabbing';
            tagContainer.style.userSelect = 'none';
            startX = e.pageX - tagContainer.offsetLeft;
            scrollLeft = tagContainer.scrollLeft;
            // Non prevenire il default qui, così il click può funzionare se non c'è movimento
        });

        tagContainer.addEventListener('mouseleave', () => {
            isDragging = false;
            clickedButton = null;
            tagContainer.style.cursor = 'grab';
            tagContainer.style.userSelect = '';
        });

        tagContainer.addEventListener('mouseup', (e) => {
            if (isDragging) {
                // Se c'è stato movimento, previeni il click sul button
                if (hasMoved && clickedButton) {
                    e.preventDefault();
                    e.stopPropagation();
                }
                
                isDragging = false;
                clickedButton = null;
                tagContainer.style.cursor = 'grab';
                tagContainer.style.userSelect = '';
                
                // Reset dopo un breve delay
                setTimeout(() => {
                    hasMoved = false;
                }, 100);
            }
        });

        tagContainer.addEventListener('mousemove', (e) => {
            if (!isDragging) return;
            
            const x = e.pageX - tagContainer.offsetLeft;
            const walk = (x - startX) * 2; // Velocità di scroll (2x)
            
            // Controlla se il movimento supera la soglia
            if (Math.abs(walk) > dragThreshold) {
                hasMoved = true;
                e.preventDefault();
                tagContainer.scrollLeft = scrollLeft - walk;
                // Metti in pausa l'animazione quando l'utente trascina
                pauseAutoScroll();
            }
        });

        // Scroll con rotella del mouse
        tagContainer.addEventListener('wheel', (e) => {
            e.preventDefault();
            tagContainer.scrollLeft += e.deltaY;
            // Metti in pausa l'animazione quando l'utente scrolla
            pauseAutoScroll();
        }, { passive: false });

        // Supporto touch per mobile - permette il drag anche quando si tocca un tag
        let touchStartX = 0;
        let touchScrollLeft = 0;
        let isTouchDragging = false;
        let touchHasMoved = false;
        let touchedButton = null;

        tagContainer.addEventListener('touchstart', (e) => {
            // Salva quale button è stato toccato (se presente)
            if (e.target.classList.contains('tag-button')) {
                touchedButton = e.target;
            } else {
                touchedButton = null;
            }
            
            isTouchDragging = true;
            touchHasMoved = false;
            touchStartX = e.touches[0].pageX - tagContainer.offsetLeft;
            touchScrollLeft = tagContainer.scrollLeft;
        }, { passive: true });

        tagContainer.addEventListener('touchmove', (e) => {
            if (!isTouchDragging) return;
            const x = e.touches[0].pageX - tagContainer.offsetLeft;
            const walk = (x - touchStartX) * 2;
            
            // Controlla se il movimento supera la soglia
            if (Math.abs(walk) > dragThreshold) {
                touchHasMoved = true;
                tagContainer.scrollLeft = touchScrollLeft - walk;
                // Metti in pausa l'animazione quando l'utente trascina
                pauseAutoScroll();
            }
        }, { passive: true });

        tagContainer.addEventListener('touchend', (e) => {
            if (isTouchDragging) {
                // Se c'è stato movimento, previeni il click sul button
                if (touchHasMoved && touchedButton) {
                    e.preventDefault();
                    e.stopPropagation();
                }
            }
            
            isTouchDragging = false;
            touchedButton = null;
            touchHasMoved = false;
        }, { passive: false });

        // Cursore grab quando si passa sopra
        tagContainer.style.cursor = 'grab';
    }

    // Funzione per inizializzare il drag e lo scroll con la rotella per gli anni
    function initYearContainerScroll() {
        if (!yearContainer) return;
        
        let isDragging = false;
        let startX = 0;
        let scrollLeft = 0;
        let hasMoved = false;
        let dragThreshold = 5; // Soglia minima per considerare un movimento come drag
        let clickedButton = null;

        // Drag con mouse - permette il drag anche quando si clicca su un anno
        yearContainer.addEventListener('mousedown', (e) => {
            // Salva quale button è stato cliccato (se presente)
            if (e.target.classList.contains('year-button')) {
                clickedButton = e.target;
            } else {
                clickedButton = null;
            }
            
            isDragging = true;
            hasMoved = false;
            yearContainer.style.cursor = 'grabbing';
            yearContainer.style.userSelect = 'none';
            startX = e.pageX - yearContainer.offsetLeft;
            scrollLeft = yearContainer.scrollLeft;
            // Non prevenire il default qui, così il click può funzionare se non c'è movimento
        });

        yearContainer.addEventListener('mouseleave', () => {
            isDragging = false;
            clickedButton = null;
            yearContainer.style.cursor = 'grab';
            yearContainer.style.userSelect = '';
        });

        yearContainer.addEventListener('mouseup', (e) => {
            if (isDragging) {
                // Se c'è stato movimento, previeni il click sul button
                if (hasMoved && clickedButton) {
                    e.preventDefault();
                    e.stopPropagation();
                }
                
                isDragging = false;
                clickedButton = null;
                yearContainer.style.cursor = 'grab';
                yearContainer.style.userSelect = '';
                
                // Reset dopo un breve delay
                setTimeout(() => {
                    hasMoved = false;
                }, 100);
            }
        });

        yearContainer.addEventListener('mousemove', (e) => {
            if (!isDragging) return;
            
            const x = e.pageX - yearContainer.offsetLeft;
            const walk = (x - startX) * 2; // Velocità di scroll (2x)
            
            // Controlla se il movimento supera la soglia
            if (Math.abs(walk) > dragThreshold) {
                hasMoved = true;
                e.preventDefault();
                yearContainer.scrollLeft = scrollLeft - walk;
                // Metti in pausa l'animazione quando l'utente trascina
                pauseAutoScrollYear();
            }
        });

        // Scroll con rotella del mouse
        yearContainer.addEventListener('wheel', (e) => {
            e.preventDefault();
            yearContainer.scrollLeft += e.deltaY;
            // Metti in pausa l'animazione quando l'utente scrolla
            pauseAutoScrollYear();
        }, { passive: false });

        // Supporto touch per mobile - permette il drag anche quando si tocca un anno
        let touchStartX = 0;
        let touchScrollLeft = 0;
        let isTouchDragging = false;
        let touchHasMoved = false;
        let touchedButton = null;

        yearContainer.addEventListener('touchstart', (e) => {
            // Salva quale button è stato toccato (se presente)
            if (e.target.classList.contains('year-button')) {
                touchedButton = e.target;
            } else {
                touchedButton = null;
            }
            
            isTouchDragging = true;
            touchHasMoved = false;
            touchStartX = e.touches[0].pageX - yearContainer.offsetLeft;
            touchScrollLeft = yearContainer.scrollLeft;
        }, { passive: true });

        yearContainer.addEventListener('touchmove', (e) => {
            if (!isTouchDragging) return;
            const x = e.touches[0].pageX - yearContainer.offsetLeft;
            const walk = (x - touchStartX) * 2;
            
            // Controlla se il movimento supera la soglia
            if (Math.abs(walk) > dragThreshold) {
                touchHasMoved = true;
                yearContainer.scrollLeft = touchScrollLeft - walk;
                // Metti in pausa l'animazione quando l'utente trascina
                pauseAutoScrollYear();
            }
        }, { passive: true });

        yearContainer.addEventListener('touchend', (e) => {
            if (isTouchDragging) {
                // Se c'è stato movimento, previeni il click sul button
                if (touchHasMoved && touchedButton) {
                    e.preventDefault();
                    e.stopPropagation();
                }
            }
            
            isTouchDragging = false;
            touchedButton = null;
            touchHasMoved = false;
        }, { passive: false });

        // Cursore grab quando si passa sopra
        yearContainer.style.cursor = 'grab';
    }

    // Funzione per selezionare/deselezionare un tag
    function toggleTag(tag) {
        if (selectedTags.has(tag)) {
            selectedTags.delete(tag);
        } else {
            selectedTags.add(tag);
        }
        
        // Aggiorna lo stato visivo dei pulsanti
        const buttons = tagContainer.querySelectorAll('.tag-button');
        buttons.forEach(button => {
            if (selectedTags.has(button.dataset.tag)) {
                button.classList.add('selected');
            } else {
                button.classList.remove('selected');
            }
        });
        
        // Metti in pausa l'animazione quando si seleziona un tag
        pauseAutoScroll();
        
        // Filtra i progetti
        filterProjects();
    }

    // Funzione per filtrare i progetti in base ai tag e agli anni selezionati
    async function filterProjects() {
        // Filtra i progetti in base ai tag e agli anni selezionati
        let filteredProjects = allProjectsData;
        
        // Filtra per tag se ce ne sono selezionati
        if (selectedTags.size > 0) {
            filteredProjects = filteredProjects.filter(projectData => {
                const projectTags = projectData.tags || [];
                return Array.from(selectedTags).some(tag => projectTags.includes(tag));
            });
        }
        
        // Filtra per anno se ce ne sono selezionati
        if (selectedYears.size > 0) {
            filteredProjects = filteredProjects.filter(projectData => {
                const projectYear = projectData.year || '';
                return selectedYears.has(projectYear);
            });
        }
        
        // Se non ci sono progetti filtrati, mostra un messaggio
        if (filteredProjects.length === 0) {
            container.innerHTML = '<p style="color: white; text-align: center; padding: 50px;">Nessun progetto trovato con i filtri selezionati</p>';
            return;
        }
        
        // Ricrea la griglia con i progetti filtrati e anima
        const { numColumns, columnWidth, gap } = getResponsiveSettings();
        
        try {
            const imagePromises = filteredProjects.map(imageData => loadImage(imageData, columnWidth));
            const results = await Promise.allSettled(imagePromises);
            const imageData = results
                .filter(result => result.status === 'fulfilled')
                .map(result => result.value);

            if (imageData.length === 0) {
                container.innerHTML = '<p style="color: white; text-align: center; padding: 50px;">Nessuna immagine disponibile</p>';
                return;
            }

            const { columns: distributedColumns, columnHeights: distributedHeights } = distributeImages(imageData, numColumns, gap);
            // Anima quando si riorganizza dopo il filtraggio
            renderColumns(distributedColumns, distributedHeights, columnWidth, gap, true);
        } catch (error) {
            console.error('Errore nel filtraggio dei progetti:', error);
        }
    }


    // Funzione per aggiustare i percorsi relativi (da Galleria/Concept/ serve un ../ in più)
    function adjustPath(path) {
        if (!path) return path;
        // Se il percorso inizia con ../, aggiungi un altro ../
        if (path.startsWith('../')) {
            return '../' + path;
        }
        return path;
    }

    function getAllImages() {
        // Usa i progetti base (non mischiati) per mantenere l'ordine sempre uguale
        // Combina tutti i progetti base (normali e open) nell'ordine originale
        const allBaseProjects = [];
        
        // Aggiungi prima i progetti normali (baseProjects se disponibile, altrimenti projects)
        if (typeof baseProjects !== 'undefined' && Array.isArray(baseProjects)) {
            allBaseProjects.push(...baseProjects);
        } else if (typeof projects !== 'undefined' && Array.isArray(projects)) {
            // Se baseProjects non è disponibile, usa projects ma prendi solo i primi 8 (numero originale)
            const uniqueProjects = [];
            const seen = new Set();
            projects.forEach(project => {
                const key = project.preview || project.name;
                if (!seen.has(key)) {
                    seen.add(key);
                    uniqueProjects.push(project);
                }
            });
            allBaseProjects.push(...uniqueProjects.slice(0, 8));
        }
        
        // Aggiungi poi i progetti open (baseOpenProjects se disponibile, altrimenti openProjects)
        if (typeof baseOpenProjects !== 'undefined' && Array.isArray(baseOpenProjects)) {
            allBaseProjects.push(...baseOpenProjects);
        } else if (typeof openProjects !== 'undefined' && Array.isArray(openProjects)) {
            // Se baseOpenProjects non è disponibile, usa openProjects ma prendi solo i primi 10 (numero originale)
            const uniqueOpenProjects = [];
            const seen = new Set();
            openProjects.forEach(project => {
                const key = project.preview || project.name;
                if (!seen.has(key)) {
                    seen.add(key);
                    uniqueOpenProjects.push(project);
                }
            });
            allBaseProjects.push(...uniqueOpenProjects.slice(0, 10));
        }
        
        // Raccogli solo le preview dei progetti (limitato a 10)
        // Ogni elemento contiene src, page e tags del progetto
        const allImages = [];
        const maxProjects = 10; // Limita a 10 progetti
        
        allBaseProjects.slice(0, maxProjects).forEach(project => {
            // Aggiungi solo la preview se esiste (aggiustando il percorso)
            if (project.preview) {
                const imageData = {
                    src: adjustPath(project.preview),
                    page: adjustPath(project.page || ''),
                    tags: project.tags || [],
                    year: project.startDate || ''
                };
                allImages.push(imageData);
                // Salva anche i dati completi per il filtraggio
                allProjectsData.push(imageData);
            }
        });
        
        // Se non ci sono immagini, usa un array vuoto
        if (allImages.length === 0) {
            console.warn('Nessuna immagine trovata nei progetti');
            return [];
        }
        
        // Restituisci le preview nell'ordine originale
        return allImages;
    }

    function getResponsiveSettings() {
        const screenWidth = window.innerWidth;
        if (screenWidth <= 576) {
            return {
                numColumns: 2,
                columnWidth: (screenWidth - 30) / 2,
                gap: 10
            };
        } else if (screenWidth <= 992) {
            return {
                numColumns: 2,
                columnWidth: (screenWidth - 45) / 2,
                gap: 15
            };
        } else {
            const numColumns = Math.max(2, Math.min(4, Math.floor((screenWidth - 100) / 320)));
            const gap = 20;
            return {
                numColumns,
                columnWidth: (screenWidth - (numColumns - 1) * gap - 40) / numColumns,
                gap
            };
        }
    }

    function loadImage(imageData, columnWidth) {
        return new Promise((resolve, reject) => {
            const img = new Image();
            img.onload = () => {
                const aspectRatio = img.naturalHeight / img.naturalWidth;
                resolve({
                    src: imageData.src,
                    page: imageData.page,
                    tags: imageData.tags || [],
                    year: imageData.year || '',
                    width: columnWidth,
                    height: columnWidth * aspectRatio,
                    aspectRatio
                });
            };
            img.onerror = reject;
            img.src = imageData.src;
        });
    }

    function distributeImages(imageData, numColumns, gap) {
        const columns = Array(numColumns).fill(null).map(() => []);
        const columnHeights = Array(numColumns).fill(0);

        imageData.forEach(data => {
            const colIndex = columnHeights.indexOf(Math.min(...columnHeights));
            columns[colIndex].push(data);
            columnHeights[colIndex] += data.height + (columns[colIndex].length > 1 ? gap : 0);
        });

        return { columns, columnHeights };
    }

    function renderColumns(columns, columnHeights, columnWidth, gap, shouldAnimate = true) {
        container.innerHTML = '';
        container.style.gap = gap + 'px';

        const columnDivs = [];
        const allImages = [];

        columns.forEach((column, colIndex) => {
            if (column.length === 0) return;

            const colDiv = document.createElement('div');
            colDiv.className = 'masonry-column';
            colDiv.style.width = columnWidth + 'px';
            colDiv.style.gap = gap + 'px';

            column.forEach((imgData, itemIndex) => {
                const item = document.createElement('div');
                item.className = 'masonry-item';
                item.dataset.columnIndex = colIndex;
                item.dataset.itemIndex = itemIndex;
                
                // Salva i tag del progetto nell'elemento per il filtraggio
                if (imgData.tags && Array.isArray(imgData.tags)) {
                    item.dataset.tags = JSON.stringify(imgData.tags);
                }

                // Crea il link se c'è una pagina del progetto
                if (imgData.page) {
                    const link = document.createElement('a');
                    link.href = imgData.page;
                    link.style.display = 'block';
                    link.style.textDecoration = 'none';
                    link.style.width = '100%';

                    const img = document.createElement('img');
                    img.src = imgData.src;
                    img.alt = '';
                    img.loading = 'lazy';
                    img.style.width = '100%';
                    img.style.height = 'auto';
                    img.style.display = 'block';
                    
                    // Traccia se l'immagine è già stata caricata
                    img.dataset.src = imgData.src;
                    if (loadedImages.has(imgData.src)) {
                        item.dataset.alreadyLoaded = 'true';
                    }

                    link.appendChild(img);
                    item.appendChild(link);
                    allImages.push(img);
                } else {
                    // Se non c'è una pagina, crea solo l'immagine
                    const img = document.createElement('img');
                    img.src = imgData.src;
                    img.alt = '';
                    img.loading = 'lazy';
                    img.style.width = '100%';
                    img.style.height = 'auto';
                    img.style.display = 'block';
                    
                    // Traccia se l'immagine è già stata caricata
                    img.dataset.src = imgData.src;
                    if (loadedImages.has(imgData.src)) {
                        item.dataset.alreadyLoaded = 'true';
                    }

                    item.appendChild(img);
                    allImages.push(img);
                }

                colDiv.appendChild(item);
            });

            container.appendChild(colDiv);
            columnDivs.push(colDiv);
        });

        if (allImages.length === 0) return;

        // Avvia le animazioni solo se shouldAnimate è true
        if (shouldAnimate) {
            const allItems = container.querySelectorAll('.masonry-item');
            allItems.forEach(item => {
                // Se l'immagine è già stata caricata, non animarla di nuovo
                if (item.dataset.alreadyLoaded === 'true') {
                    item.classList.add('animate');
                    return;
                }
                
                const colIndex = parseInt(item.dataset.columnIndex) || 0;
                const itemIndex = parseInt(item.dataset.itemIndex) || 0;
                const delay = (ANIMATION_BASE_DELAY + colIndex * COLUMN_DELAY + itemIndex * ITEM_DELAY) * 1000;
                setTimeout(() => item.classList.add('animate'), delay);
            });
        } else {
            // Se non si deve animare, mostra immediatamente tutti gli elementi
            const allItems = container.querySelectorAll('.masonry-item');
            allItems.forEach(item => {
                item.classList.add('animate');
            });
        }

        // Funzione per allineare le colonne (può essere chiamata dopo il caricamento)
        const alignColumns = () => {
            container.offsetHeight;

            const actualHeights = columnDivs.map(colDiv => {
                colDiv.style.paddingBottom = '0';
                return colDiv.offsetHeight;
            });

            const maxHeight = Math.max(...actualHeights);
            columnDivs.forEach((colDiv, index) => {
                const currentHeight = actualHeights[index];
                if (currentHeight < maxHeight && currentHeight > 0) {
                    colDiv.style.paddingBottom = (maxHeight - currentHeight) + 'px';
                }
            });
        };

        // Allinea le colonne dopo un breve delay per permettere al layout di stabilizzarsi
        requestAnimationFrame(() => {
            setTimeout(alignColumns, 100);
        });

        // Allinea nuovamente quando tutte le immagini sono caricate (per correggere eventuali disallineamenti)
        let loadedCount = 0;
        const checkLoaded = () => {
            loadedCount++;
            if (loadedCount === allImages.length) {
                // Aspetta un frame per permettere alle immagini di renderizzarsi
                requestAnimationFrame(() => {
                    setTimeout(alignColumns, 0);
                });
                
                // Mostra il footer dopo che le immagini sono caricate
                const footer = document.querySelector('.gallery-footer');
                if (footer) {
                    footer.classList.add('visible');
                }
            }
        };

        allImages.forEach(img => {
            if (img.complete) {
                // Se l'immagine è già caricata, aggiungila al set
                if (img.dataset.src) {
                    loadedImages.add(img.dataset.src);
                }
                checkLoaded();
            } else {
                img.addEventListener('load', () => {
                    // Aggiungi l'immagine al set quando viene caricata
                    if (img.dataset.src) {
                        loadedImages.add(img.dataset.src);
                    }
                    checkLoaded();
                });
                img.addEventListener('error', checkLoaded);
            }
        });
    }

    async function createMasonryGrid(shouldAnimate = true) {
        // Evita ricreazioni multiple
        if (isCreatingGrid) {
            console.log('Griglia già in creazione, skip...');
            return;
        }
        
        isCreatingGrid = true;
        
        // Timeout di sicurezza per resettare il flag dopo 10 secondi
        const safetyTimeout = setTimeout(() => {
            if (isCreatingGrid) {
                console.warn('Timeout nella creazione della griglia, reset del flag');
                isCreatingGrid = false;
            }
        }, 10000);
        
        try {
            // Reset dei dati dei progetti quando si ricrea la griglia
            allProjectsData = [];
            
            const images = getAllImages();
            if (images.length === 0) {
                container.innerHTML = '<p style="color: white; text-align: center; padding: 50px;">Nessuna immagine trovata</p>';
                clearTimeout(safetyTimeout);
                isCreatingGrid = false;
                return;
            }

            const { numColumns, columnWidth, gap } = getResponsiveSettings();
            
            // Carica le immagini in batch progressivi per migliorare le prestazioni
            const BATCH_SIZE = 20; // Carica 20 immagini alla volta
            let allImageData = [];
            let currentBatch = 0;
            
            // Funzione per caricare un batch di immagini
            const loadBatch = async (batchStart) => {
                const batchEnd = Math.min(batchStart + BATCH_SIZE, images.length);
                const batch = images.slice(batchStart, batchEnd);
                
                const imagePromises = batch.map(imageData => loadImage(imageData, columnWidth));
                const results = await Promise.allSettled(imagePromises);
                const batchImageData = results
                    .filter(result => result.status === 'fulfilled')
                    .map(result => result.value);
                
                return batchImageData;
            };
            
            // Carica il primo batch e mostra subito la griglia
            const firstBatch = await loadBatch(0);
            allImageData.push(...firstBatch);
            
            if (allImageData.length === 0) {
                container.innerHTML = '<p style="color: white; text-align: center; padding: 50px;">Nessuna immagine disponibile</p>';
                clearTimeout(safetyTimeout);
                isCreatingGrid = false;
                return;
            }
            
            // Mostra subito la griglia con il primo batch
            const { columns: distributedColumns, columnHeights: distributedHeights } = distributeImages(allImageData, numColumns, gap);
            renderColumns(distributedColumns, distributedHeights, columnWidth, gap, shouldAnimate);
            
            // Carica il resto delle immagini in background e aggiorna la griglia progressivamente
            currentBatch = BATCH_SIZE;
            while (currentBatch < images.length) {
                const nextBatch = await loadBatch(currentBatch);
                if (nextBatch.length > 0) {
                    allImageData.push(...nextBatch);
                    // Ricalcola la distribuzione con tutte le immagini caricate finora
                    const { columns: updatedColumns, columnHeights: updatedHeights } = distributeImages(allImageData, numColumns, gap);
                    renderColumns(updatedColumns, updatedHeights, columnWidth, gap, false); // false per evitare animazioni multiple
                }
                currentBatch += BATCH_SIZE;
                
                // Piccola pausa tra i batch per non bloccare il browser
                await new Promise(resolve => setTimeout(resolve, 50));
            }
        } catch (error) {
            console.error('Errore nel caricamento delle immagini:', error);
        } finally {
            // Reset del flag quando la funzione è completata
            clearTimeout(safetyTimeout);
            isCreatingGrid = false;
        }
    }

    // Pre-carica tutte le immagini prima di avviare le animazioni
    function preloadAllImages() {
        return new Promise((resolve) => {
            const images = getAllImages();
            if (images.length === 0) {
                resolve();
                return;
            }
            
            let loadedCount = 0;
            let errorCount = 0;
            const totalImages = images.length;
            
            function checkComplete() {
                if (loadedCount + errorCount >= totalImages) {
                    resolve();
                }
            }
            
            // Carica tutte le immagini in parallelo (ma con un limite per non sovraccaricare)
            const maxConcurrent = 10;
            let currentIndex = 0;
            let activeLoads = 0;
            
            function loadNextBatch() {
                while (activeLoads < maxConcurrent && currentIndex < totalImages) {
                    const imageData = images[currentIndex];
                    currentIndex++;
                    activeLoads++;
                    
                    const img = new Image();
                    img.onload = () => {
                        loadedImages.add(imageData.src);
                        loadedCount++;
                        activeLoads--;
                        checkComplete();
                        if (currentIndex < totalImages) {
                            loadNextBatch();
                        }
                    };
                    img.onerror = () => {
                        errorCount++;
                        activeLoads--;
                        checkComplete();
                        if (currentIndex < totalImages) {
                            loadNextBatch();
                        }
                    };
                    img.src = imageData.src;
                }
            }
            
            // Inizia il caricamento
            loadNextBatch();
        });
    }
    
    // Funzione per aspettare che finisca il ciclo corrente di rotazione
    function waitForRotationCycle() {
        return new Promise((resolve) => {
            // L'animazione dura 1s, aspetta che finisca il ciclo corrente
            // Calcola quando finirà il prossimo ciclo completo
            const animationDuration = 1000; // 1 secondo
            const now = performance.now();
            const elapsed = now % animationDuration;
            const timeUntilNextCycle = animationDuration - elapsed;
            
            // Aspetta che finisca il ciclo corrente (fino al 100% dell'animazione)
            // Aggiungiamo un piccolo buffer per assicurarci che sia completato
            setTimeout(() => {
                resolve();
            }, timeUntilNextCycle + 100);
        });
    }
    
    // Avvia le animazioni senza aspettare il pre-caricamento completo delle immagini
    // Le immagini verranno caricate in modo lazy durante il rendering
    waitForRotationCycle().then(() => {
            // Quando il ciclo è completato, ferma la rotazione e avvia le animazioni
            const logoCircle = document.getElementById('logo-circle');
            const header = document.querySelector('.header');
            const headerRectangle = document.querySelector('.header-rectangle');
            
            if (logoCircle) {
                // Ferma l'animazione di rotazione
                logoCircle.style.animation = 'none';
                
                // Forza un reflow per applicare il cambio
                void logoCircle.offsetHeight;
                
                // Rimuovi tutti gli stili inline che potrebbero interferire
                logoCircle.style.removeProperty('animation');
                logoCircle.style.removeProperty('animation-name');
                logoCircle.style.removeProperty('animation-duration');
                logoCircle.style.removeProperty('animation-timing-function');
                logoCircle.style.removeProperty('animation-delay');
                logoCircle.style.removeProperty('animation-iteration-count');
                logoCircle.style.removeProperty('animation-direction');
                logoCircle.style.removeProperty('animation-fill-mode');
                
                // Forza un altro reflow
                void logoCircle.offsetHeight;
                
                // Aggiungi la classe loaded che avvierà la nuova animazione
                logoCircle.classList.add('loaded');
                
                // Usa animationend event per essere sicuri che l'animazione sia completata
                const handleAnimationEnd = (e) => {
                    // Supporta sia l'animazione desktop che mobile
                    if (e.animationName === 'moveToBottomAndRotate' || 
                        e.animationName === 'moveToBottomAndRotateMobile' || 
                        logoCircle.classList.contains('loaded')) {
                        // Rimuovi l'event listener dopo l'uso
                        logoCircle.removeEventListener('animationend', handleAnimationEnd);
                        // Assicurati che l'header sia caricato prima di inizializzare la fisica
                        // Questo previene il problema del cerchio che si sposta prima della scritta "Works"
                        const headerLoaded = header && header.classList.contains('loaded');
                        const headerRectLoaded = headerRectangle && headerRectangle.classList.contains('loaded');
                        
                        // Se l'header non è ancora caricato, aspetta
                        if (!headerLoaded || !headerRectLoaded) {
                            const checkHeader = setInterval(() => {
                                const hLoaded = header && header.classList.contains('loaded');
                                const hrLoaded = headerRectangle && headerRectangle.classList.contains('loaded');
                                if (hLoaded && hrLoaded) {
                                    clearInterval(checkHeader);
                                    // Inizializza la fisica del cerchio dopo che l'animazione è completata
                                    const isMobile = window.innerWidth <= 768;
                                    const delay = isMobile ? 100 : 50;
                                    setTimeout(() => {
                                        if (logoCircle && typeof initializeCirclePhysics === 'function') {
                                            initializeCirclePhysics();
                                        }
                                    }, delay);
                                }
                            }, 50);
                            // Timeout di sicurezza dopo 1 secondo
                            setTimeout(() => {
                                clearInterval(checkHeader);
                                if (logoCircle && typeof initializeCirclePhysics === 'function') {
                                    initializeCirclePhysics();
                                }
                            }, 1000);
                        } else {
                            // Inizializza la fisica del cerchio dopo che l'animazione è completata
                            // Su mobile, aspetta un po' di più per assicurarsi che l'animazione sia completamente finita
                            const isMobile = window.innerWidth <= 768;
                            const delay = isMobile ? 100 : 50;
                            setTimeout(() => {
                                if (logoCircle && typeof initializeCirclePhysics === 'function') {
                                    initializeCirclePhysics();
                                }
                            }, delay);
                        }
                    }
                };
                
                logoCircle.addEventListener('animationend', handleAnimationEnd);
                
                // Fallback con timeout nel caso animationend non funzioni
                // Su mobile, aspetta più tempo per l'animazione
                const isMobileDevice = window.innerWidth <= 768;
                const fallbackTimeout = isMobileDevice ? 900 : 700;
                
                setTimeout(() => {
                    if (logoCircle && typeof initializeCirclePhysics === 'function') {
                        // Calcola l'offset corretto per mobile
                        const isMobile = window.innerWidth <= 768;
                        const circleBottomOffset = isMobile ? 80 : CIRCLE_REST_BOTTOM;
                        
                        // Verifica se l'animazione è completata controllando la posizione
                        const pos = getCirclePosition();
                        const expectedBottom = window.innerHeight - circleBottomOffset - CIRCLE_SIZE / 2;
                        const centerThreshold = window.innerHeight / 2;
                        
                        // Tolleranza adattiva (più grande su mobile)
                        const tolerance = Math.max(100, window.innerHeight * 0.15);
                        const isAtBottom = Math.abs(pos.top - expectedBottom) < tolerance;
                        const isAtCenter = Math.abs(pos.top - centerThreshold) < tolerance;
                        
                        if ((!isAtBottom && !isAtCenter) && logoCircle.classList.contains('loaded')) {
                            // Se non è nella posizione corretta ma l'animazione dovrebbe essere finita, forza il posizionamento
                            initializeCirclePhysics();
                        } else if (isAtCenter && !menuOpen && logoCircle.classList.contains('loaded')) {
                            // Se è ancora al centro, correggilo
                            initializeCirclePhysics();
                        }
                    }
                }, fallbackTimeout);
            }
            // Assicurati che l'header sia caricato PRIMA di spostare il cerchio
            // Questo previene il problema del cerchio che si sposta prima della scritta "Works"
            if (header) {
                header.classList.add('loaded');
            }
            if (headerRectangle) {
                headerRectangle.classList.add('loaded');
            }
            
            // Mostra le sezioni tag e anno quando l'header è caricato
            if (tagFilterSection) {
                setTimeout(() => {
                    tagFilterSection.classList.add('visible');
                    tagFilterSection.classList.add('loaded');
                    createTagButtons();
                }, 500);
            }
            
            if (yearFilterSection) {
                setTimeout(() => {
                    yearFilterSection.classList.add('visible');
                    yearFilterSection.classList.add('loaded');
                    createYearButtons();
                }, 500);
            }
            
            // Crea la griglia dopo che le animazioni del cerchio e header sono partite
            // Su mobile, ritarda di più per evitare che si carichi troppo presto
            const isMobile = window.innerWidth <= 768;
            const headerAnimationDelay = 500; // Tempo per l'animazione dell'header
            const gridDelay = isMobile ? LOGO_ANIMATION_DELAY + 500 + headerAnimationDelay : LOGO_ANIMATION_DELAY + headerAnimationDelay;
            setTimeout(() => createMasonryGrid(), gridDelay);
        });

    let resizeTimer;
    let tagResizeTimer;
    let lastWindowWidth = window.innerWidth;
    let lastWindowHeight = window.innerHeight;
    const RESIZE_THRESHOLD = 50; // Soglia minima di cambiamento per considerare un resize significativo
    
    window.addEventListener('resize', () => {
        const currentWidth = window.innerWidth;
        const currentHeight = window.innerHeight;
        const widthChange = Math.abs(currentWidth - lastWindowWidth);
        const heightChange = Math.abs(currentHeight - lastWindowHeight);
        
        // Su mobile, ignora i cambiamenti di altezza (causati dalla barra degli indirizzi)
        // Ricrea la griglia solo se c'è un cambiamento significativo nella larghezza
        const isMobile = window.innerWidth <= 768;
        const shouldResize = isMobile 
            ? widthChange > RESIZE_THRESHOLD  // Solo larghezza su mobile
            : (widthChange > RESIZE_THRESHOLD || heightChange > RESIZE_THRESHOLD); // Larghezza o altezza su desktop
        
        if (shouldResize) {
            lastWindowWidth = currentWidth;
            lastWindowHeight = currentHeight;
            
            clearTimeout(resizeTimer);
            // Al resize, ricrea la griglia senza animazione
            resizeTimer = setTimeout(() => {
                createMasonryGrid(false);
            }, 250);
        }
        
        // Controlla se l'animazione dei tag deve essere riavviata o fermata (sempre, anche per piccoli resize)
        clearTimeout(tagResizeTimer);
        tagResizeTimer = setTimeout(() => {
            // Riavvia l'animazione se necessario (si fermerà automaticamente se non c'è contenuto scrollabile)
            startAutoScroll();
            startAutoScrollYear();
        }, 300);
    });

    // Back to top functionality
    const backToTopLink = document.querySelector('.back-to-top');
    if (backToTopLink) {
        backToTopLink.addEventListener('click', (e) => {
            e.preventDefault();
            window.scrollTo({ top: 0, behavior: 'smooth' });
        });
    }

    // Menu functionality
    const logoCircle = document.getElementById('logo-circle');
    const bottomMenu = document.getElementById('bottom-menu');
    const MENU_HEIGHT = 400;
    let menuOpen = false;
    
    function toggleMenuFromPosition(circleTop) {
        // Calcola l'offset corretto per mobile
        const isMobile = window.innerWidth <= 768;
        const circleBottomOffset = isMobile ? 80 : CIRCLE_REST_BOTTOM;
        
        // Determina lo stato corrente del menu basandosi sulla posizione del cerchio fornita
        const closedRestTop = window.innerHeight - circleBottomOffset - CIRCLE_SIZE / 2;
        const currentDragUpDistance = closedRestTop - circleTop;
        
        // Se il cerchio è sopra la posizione di riposo, il menu è aperto (almeno parzialmente)
        const isCurrentlyOpen = currentDragUpDistance > MENU_HEIGHT * 0.5;
        
        // Inverti lo stato: se è aperto, chiudilo; se è chiuso, aprilo
        const newMenuOpen = !isCurrentlyOpen;
        
        // Aggiorna la variabile di stato
        menuOpen = newMenuOpen;
        
        // Aggiorna il menu visivamente
        if (bottomMenu) {
            // Rimuovi la classe dragging per permettere la transizione
            bottomMenu.classList.remove('dragging');
            
            // Assicurati che la transizione CSS sia attiva
            bottomMenu.style.transition = 'height 0.2s ease-out';
            
            if (menuOpen) {
                bottomMenu.classList.add('open');
                bottomMenu.style.height = MENU_HEIGHT + 'px';
            } else {
                bottomMenu.classList.remove('open');
                bottomMenu.style.height = '0px';
            }
        }
        
        // Aggiorna la posizione di riposo del cerchio quando il menu si apre/chiude
        updateCircleRestPosition();
        
        // Anima il cerchio alla nuova posizione
        if (!isDragging && logoCircle) {
            // Ferma qualsiasi animazione a molla in corso
            if (springAnimId) {
                cancelAnimationFrame(springAnimId);
                springAnimId = null;
            }
            
            // Rimuovi completamente l'animazione CSS e qualsiasi stile che potrebbe interferire
            logoCircle.style.animation = 'none';
            logoCircle.style.removeProperty('animation');
            logoCircle.style.removeProperty('animation-name');
            logoCircle.style.removeProperty('animation-duration');
            logoCircle.style.removeProperty('animation-timing-function');
            logoCircle.style.removeProperty('animation-delay');
            logoCircle.style.removeProperty('animation-iteration-count');
            logoCircle.style.removeProperty('animation-direction');
            logoCircle.style.removeProperty('animation-fill-mode');
            void logoCircle.offsetHeight; // Forza reflow
            
            // Leggi la posizione corrente PRIMA di impostare la transizione
            const currentPos = getCirclePosition();
            const currentTop = currentPos.top;
            const currentLeft = currentPos.left;
            
            // Imposta la nuova posizione target (assicurati che circleRestTop sia stato aggiornato)
            // Se circleRestTop non è valido, ricalcolalo
            if (!circleRestTop || circleRestTop <= 0) {
                updateCircleRestPosition();
            }
            
            const targetTop = circleRestTop;
            const targetLeft = circleRestLeft || window.innerWidth / 2;
            
            // Se la posizione target è diversa dalla corrente, anima
            if (Math.abs(targetTop - currentTop) > 1 || Math.abs(targetLeft - currentLeft) > 1) {
                // Usa una transizione CSS con la stessa velocità del menu (0.2s ease-out)
                logoCircle.style.transition = 'top 0.2s ease-out, left 0.2s ease-out';
                
                // Imposta direttamente la posizione usando setProperty con !important
                // IMPORTANTE: imposta top PRIMA di left per evitare conflitti
                logoCircle.style.setProperty('top', targetTop + 'px', 'important');
                logoCircle.style.setProperty('left', targetLeft + 'px', 'important');
                logoCircle.style.setProperty('transform', 'translate(-50%, -50%)', 'important');
                
                // Forza un reflow per assicurarsi che le modifiche siano applicate
                void logoCircle.offsetHeight;
                
                // Aggiorna anche circleRestLeft e circleRestTop
                circleRestLeft = targetLeft;
                circleRestTop = targetTop;
                
                // Rimuovi la transizione dopo l'animazione per permettere il drag
                setTimeout(() => {
                    if (logoCircle && !isDragging) {
                        logoCircle.style.transition = '';
                        logoCircle.style.removeProperty('transition');
                    }
                }, 200);
            }
        }
    }
    
    function toggleMenu() {
        // Determina lo stato corrente del menu basandosi sulla posizione REALE del cerchio
        if (!logoCircle) return;
        
        // Leggi la posizione corrente reale del cerchio
        const pos = getCirclePosition();
        const currentTop = pos.top;
        
        // Calcola l'offset corretto per mobile
        const isMobile = window.innerWidth <= 768;
        const circleBottomOffset = isMobile ? 80 : CIRCLE_REST_BOTTOM;
        
        // Determina lo stato corrente del menu basandosi sulla posizione del cerchio
        const closedRestTop = window.innerHeight - circleBottomOffset - CIRCLE_SIZE / 2;
        const currentDragUpDistance = closedRestTop - currentTop;
        
        // Se il cerchio è sopra la posizione di riposo, il menu è aperto (almeno parzialmente)
        const isCurrentlyOpen = currentDragUpDistance > MENU_HEIGHT * 0.5;
        
        // Inverti lo stato: se è aperto, chiudilo; se è chiuso, aprilo
        menuOpen = !isCurrentlyOpen;
        
        // Aggiorna la posizione di riposo del cerchio quando il menu si apre/chiude
        updateCircleRestPosition();
        
        // Anima il cerchio e il menu in sincronia usando requestAnimationFrame
        // per assicurarsi che inizino nello stesso frame
        requestAnimationFrame(() => {
            // Aggiorna il menu visivamente
            if (bottomMenu) {
                // Rimuovi la classe dragging per permettere la transizione
                bottomMenu.classList.remove('dragging');
                
                // Assicurati che la transizione CSS sia attiva
                bottomMenu.style.transition = 'height 0.2s ease-out';
                
                if (menuOpen) {
                    bottomMenu.classList.add('open');
                    bottomMenu.style.height = MENU_HEIGHT + 'px';
                } else {
                    bottomMenu.classList.remove('open');
                    bottomMenu.style.height = '0px';
                }
            }
            
            // Anima il cerchio alla nuova posizione con la stessa velocità del menu
            if (!isDragging && logoCircle) {
            // Ferma qualsiasi animazione a molla in corso
            if (springAnimId) {
                cancelAnimationFrame(springAnimId);
                springAnimId = null;
            }
            
            // Rimuovi completamente l'animazione CSS e qualsiasi stile che potrebbe interferire
            logoCircle.style.animation = 'none';
            logoCircle.style.removeProperty('animation');
            logoCircle.style.removeProperty('animation-name');
            logoCircle.style.removeProperty('animation-duration');
            logoCircle.style.removeProperty('animation-timing-function');
            logoCircle.style.removeProperty('animation-delay');
            logoCircle.style.removeProperty('animation-iteration-count');
            logoCircle.style.removeProperty('animation-direction');
            logoCircle.style.removeProperty('animation-fill-mode');
            void logoCircle.offsetHeight; // Forza reflow
            
            // Leggi la posizione corrente PRIMA di impostare la transizione
            const currentPos = getCirclePosition();
            const currentCircleTop = currentPos.top;
            const currentCircleLeft = currentPos.left;
            
            // Imposta la nuova posizione target
            if (!circleRestTop || circleRestTop <= 0) {
                updateCircleRestPosition();
            }
            
            const targetTop = circleRestTop;
            const targetLeft = circleRestLeft || window.innerWidth / 2;
            
            // Se la posizione target è diversa dalla corrente, anima
            if (Math.abs(targetTop - currentCircleTop) > 1 || Math.abs(targetLeft - currentCircleLeft) > 1) {
                // Usa una transizione CSS con la stessa velocità del menu (0.2s ease-out)
                // Usa requestAnimationFrame per sincronizzare meglio con il menu
                requestAnimationFrame(() => {
                    logoCircle.style.transition = 'top 0.2s ease-out, left 0.2s ease-out';
                    
                    // Imposta direttamente la posizione usando setProperty con !important
                    logoCircle.style.setProperty('top', targetTop + 'px', 'important');
                    logoCircle.style.setProperty('left', targetLeft + 'px', 'important');
                    logoCircle.style.setProperty('transform', 'translate(-50%, -50%)', 'important');
                    
                    // Forza un reflow per assicurarsi che le modifiche siano applicate
                    void logoCircle.offsetHeight;
                });
                
                // Aggiorna anche circleRestLeft e circleRestTop
                circleRestLeft = targetLeft;
                circleRestTop = targetTop;
                
                // Rimuovi la transizione dopo l'animazione per permettere il drag
                setTimeout(() => {
                    if (logoCircle && !isDragging) {
                        logoCircle.style.transition = '';
                        logoCircle.style.removeProperty('transition');
                    }
                }, 200);
            }
            }
        });
    }
    
    function updateCircleRestPosition() {
        // Calcola la nuova posizione di riposo basata sullo stato del menu
        // Su mobile, usa un valore più basso per CIRCLE_REST_BOTTOM
        const isMobile = window.innerWidth <= 768;
        const circleBottomOffset = isMobile ? 80 : CIRCLE_REST_BOTTOM;
        
        if (menuOpen) {
            // Quando il menu è aperto, il cerchio è al centro (come nella home)
            circleRestTop = window.innerHeight / 2;
        } else {
            // Quando il menu è chiuso, posizione normale
            circleRestTop = window.innerHeight - circleBottomOffset - CIRCLE_SIZE / 2;
        }
    }
    
    function updateMenuHeightFromCircle(circleTop) {
        if (!bottomMenu) return;
        
        // Calcola l'offset corretto per mobile
        const isMobile = window.innerWidth <= 768;
        const circleBottomOffset = isMobile ? 80 : CIRCLE_REST_BOTTOM;
        
        // Calcola la posizione di riposo quando il menu è chiuso
        const closedRestTop = window.innerHeight - circleBottomOffset - CIRCLE_SIZE / 2;
        
        // Calcola quanto il cerchio è sopra la posizione di riposo chiusa
        const dragUpDistance = closedRestTop - circleTop;
        
        // Limita l'altezza del menu tra 0 e MENU_HEIGHT basata sulla distanza trascinata verso l'alto
        // Usa Math.max per gestire anche quando il cerchio viene trascinato verso il basso (dragUpDistance negativo)
        const menuHeight = Math.max(0, Math.min(MENU_HEIGHT, dragUpDistance));
        
        // Applica sempre l'altezza calcolata (rimuove qualsiasi altezza fissa precedente)
        bottomMenu.style.height = menuHeight + 'px';
        
        // Aggiorna lo stato del menu in base all'altezza
        const newMenuOpen = menuHeight > MENU_HEIGHT * 0.5;
        
        // Aggiorna la classe solo se lo stato è cambiato
        if (newMenuOpen !== menuOpen) {
            menuOpen = newMenuOpen;
            if (menuOpen) {
                bottomMenu.classList.add('open');
            } else {
                bottomMenu.classList.remove('open');
            }
        }
    }
    

    // Spring physics per il cerchio
    const CIRCLE_REST_BOTTOM = 100;
    const CIRCLE_SIZE = 60;
    let circleRestTop = 0;
    let circleRestLeft = 0;
    let isDragging = false;
    let dragStartX = 0;
    let dragStartY = 0;
    let dragStartLeft = 0;
    let dragStartTop = 0;
    let currentCircleLeft = 0;
    let currentCircleTop = 0;
    let springAnimId = null;
    let hasMoved = false;

    // Imposta posizione cerchio (rimuove animazione CSS e imposta posizione precisa)
    function setCirclePosition(left, top, preserveTransition = false) {
        if (!logoCircle) return;
        // Rimuovi sempre l'animazione CSS quando iniziamo a controllare con JavaScript
        // (le animazioni CSS interferiscono con il controllo JavaScript)
        logoCircle.style.animation = 'none';
        logoCircle.style.removeProperty('animation');
        logoCircle.style.removeProperty('animation-name');
        logoCircle.style.removeProperty('animation-duration');
        logoCircle.style.removeProperty('animation-timing-function');
        logoCircle.style.removeProperty('animation-delay');
        logoCircle.style.removeProperty('animation-iteration-count');
        logoCircle.style.removeProperty('animation-direction');
        logoCircle.style.removeProperty('animation-fill-mode');
        // Ma preserva la transizione se richiesto
        if (!preserveTransition) {
            logoCircle.style.transition = '';
            logoCircle.style.removeProperty('transition');
        }
        // IMPORTANTE: imposta top e left come stili inline con !important per sovrascrivere qualsiasi CSS
        logoCircle.style.setProperty('left', left + 'px', 'important');
        logoCircle.style.setProperty('top', top + 'px', 'important');
        logoCircle.style.setProperty('transform', 'translate(-50%, -50%)', 'important');
        // Forza il reflow per assicurare che le modifiche siano applicate
        void logoCircle.offsetHeight;
    }

    // Leggi la posizione reale del cerchio
    function getCirclePosition() {
        if (!logoCircle) return { left: 0, top: 0 };
        const rect = logoCircle.getBoundingClientRect();
        // Ritorna il centro del cerchio (perché usa translate(-50%, -50%))
        return {
            left: rect.left + rect.width / 2,
            top: rect.top + rect.height / 2
        };
    }

    // Animazione a molla per entrambi gli assi
    function animateSpring(targetLeft, targetTop, startLeft, startTop, velocityX = 0, velocityY = 0) {
        if (springAnimId) {
            cancelAnimationFrame(springAnimId);
        }

        const SPRING = 0.35;
        const DAMPING = 0.75;
        let posX = startLeft;
        let posY = startTop;
        let velX = velocityX;
        let velY = velocityY;

        function step() {
            const distX = targetLeft - posX;
            const distY = targetTop - posY;
            
            const forceX = distX * SPRING;
            const forceY = distY * SPRING;
            const dampingX = velX * DAMPING;
            const dampingY = velY * DAMPING;
            
            const accelX = forceX - dampingX;
            const accelY = forceY - dampingY;

            velX += accelX;
            velY += accelY;
            posX += velX;
            posY += velY;

            setCirclePosition(posX, posY);

            // Condizioni di stop: ferma quando sia X che Y sono stabili
            if (Math.abs(distX) < 0.3 && Math.abs(distY) < 0.3 && 
                Math.abs(velX) < 0.15 && Math.abs(velY) < 0.15) {
                setCirclePosition(targetLeft, targetTop);
                circleRestLeft = targetLeft;
                circleRestTop = targetTop;
                springAnimId = null;
                // Reset hasMoved dopo che l'animazione è completata per permettere i click successivi
                hasMoved = false;
                return;
            }

            springAnimId = requestAnimationFrame(step);
        }

        step();
    }

    // Inizializza dopo animazione CSS
    // Usa animationend event per essere sicuri che l'animazione sia finita
    function initializeCirclePhysics() {
        if (!logoCircle) return;
        
        // Calcola sempre la posizione corretta basandosi sullo stato del menu
        updateCircleRestPosition();
        circleRestLeft = window.innerWidth / 2;
        
        // Calcola l'offset corretto per mobile
        const isMobile = window.innerWidth <= 768;
        const circleBottomOffset = isMobile ? 80 : CIRCLE_REST_BOTTOM;
        
        // Se circleRestTop non è valido, calcolalo di nuovo
        if (!circleRestTop || circleRestTop <= 0) {
            // Menu è chiuso di default all'inizio
            circleRestTop = window.innerHeight - circleBottomOffset - CIRCLE_SIZE / 2;
        }
        
        // Leggi la posizione REALE corrente del cerchio
        const currentPos = getCirclePosition();
        const currentTop = currentPos.top;
        const currentLeft = currentPos.left;
        
        // Calcola la posizione target corretta
        const expectedBottom = window.innerHeight - circleBottomOffset - CIRCLE_SIZE / 2;
        const centerThreshold = window.innerHeight / 2;
        
        // Tolleranza maggiore su mobile (circa 10% dell'altezza dello schermo)
        const tolerance = Math.max(50, window.innerHeight * 0.1);
        const isAtCenter = Math.abs(currentTop - centerThreshold) < tolerance;
        const isAtExpectedBottom = Math.abs(currentTop - expectedBottom) < tolerance;
        
        if (isAtCenter || currentTop <= 0 || (!isAtExpectedBottom && !menuOpen)) {
            // Il cerchio è ancora al centro o in posizione errata, forza il posizionamento corretto
            circleRestTop = expectedBottom;
            circleRestLeft = window.innerWidth / 2;
            
            // Imposta direttamente la posizione corretta senza transizione per essere sicuri
            setCirclePosition(circleRestLeft, circleRestTop);
        } else {
            // Il cerchio è in una posizione valida, usa quella
            circleRestTop = currentTop;
            circleRestLeft = currentLeft;
            setCirclePosition(circleRestLeft, circleRestTop);
        }
        
        // Verifica nuovamente dopo un breve delay per assicurarsi che la posizione sia corretta
        // Su mobile, aspetta un po' di più
        const verifyDelay = isMobile ? 150 : 100;
        setTimeout(() => {
            if (!isDragging && !springAnimId) {
                const verifyPos = getCirclePosition();
                const verifyExpectedBottom = window.innerHeight - circleBottomOffset - CIRCLE_SIZE / 2;
                const verifyCenter = window.innerHeight / 2;
                const verifyTolerance = Math.max(50, window.innerHeight * 0.1);
                
                if (Math.abs(verifyPos.top - verifyCenter) < verifyTolerance && !menuOpen) {
                    // Il cerchio è ancora al centro, correggilo
                    circleRestTop = verifyExpectedBottom;
                    circleRestLeft = window.innerWidth / 2;
                    setCirclePosition(circleRestLeft, circleRestTop);
                }
            }
        }, verifyDelay);

        if (bottomMenu) {

            // Drag con mouse
            let totalDragDistance = 0;
            
            logoCircle.addEventListener('mousedown', (e) => {
                e.preventDefault();
                e.stopPropagation();
                
                // Ferma qualsiasi animazione in corso
                if (springAnimId) {
                    cancelAnimationFrame(springAnimId);
                    springAnimId = null;
                }
                
                // Rimuovi transizione per movimento fluido durante il drag
                logoCircle.style.transition = 'none';
                if (bottomMenu) {
                    bottomMenu.classList.add('dragging');
                }
                
                isDragging = true;
                hasMoved = false;
                totalDragDistance = 0;
                dragStartX = e.clientX;
                dragStartY = e.clientY;
                
                // Leggi la posizione ATTUALE reale del cerchio
                const pos = getCirclePosition();
                dragStartLeft = pos.left;
                dragStartTop = pos.top;
                currentCircleLeft = dragStartLeft;
                currentCircleTop = dragStartTop;
                
                // Aggiorna il menu in base alla posizione iniziale del cerchio
                // Questo assicura che il menu parta dalla posizione corretta quando si inizia un nuovo drag
                updateMenuHeightFromCircle(dragStartTop);
                
                logoCircle.classList.add('dragging');
            });

            document.addEventListener('mousemove', (e) => {
                if (isDragging && logoCircle) {
                    const deltaX = e.clientX - dragStartX;
                    const deltaY = e.clientY - dragStartY;
                    
                    // Calcola la distanza totale del drag
                    totalDragDistance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                    
                    if (Math.abs(deltaX) > 5 || Math.abs(deltaY) > 5) {
                        hasMoved = true;
                    }
                    
                    // Applica rapporto 3/4 al movimento del mouse
                    const moveRatio = 0.75;
                    currentCircleLeft = dragStartLeft + (deltaX * moveRatio);
                    currentCircleTop = dragStartTop + (deltaY * moveRatio);
                    
                    // Limita movimento (opzionale, per evitare che esca dallo schermo)
                    const minLeft = CIRCLE_SIZE / 2;
                    const maxLeft = window.innerWidth - CIRCLE_SIZE / 2;
                    const minTop = CIRCLE_SIZE / 2;
                    const maxTop = window.innerHeight - CIRCLE_SIZE / 2;
                    
                    currentCircleLeft = Math.max(minLeft, Math.min(maxLeft, currentCircleLeft));
                    currentCircleTop = Math.max(minTop, Math.min(maxTop, currentCircleTop));
                    
                    setCirclePosition(currentCircleLeft, currentCircleTop);
                    
                    // Aggiorna sempre l'altezza del menu in base alla posizione del cerchio durante il drag
                    // Il menu deve seguire il cerchio in tempo reale
                    updateMenuHeightFromCircle(currentCircleTop);
                }
            });

            document.addEventListener('mouseup', (e) => {
                if (isDragging) {
                    isDragging = false;
                    logoCircle.classList.remove('dragging');
                    
                    if (bottomMenu) {
                        bottomMenu.classList.remove('dragging');
                    }
                    
                    // Se il drag è minore di 8px, considera come click e apri/chiudi menu
                    if (totalDragDistance < 8) {
                        // Usa toggleMenu() che legge la posizione corrente reale del cerchio
                        toggleMenu();
                        
                        // Reset immediato per permettere click successivi
                        hasMoved = false;
                        totalDragDistance = 0;
                        return;
                    }
                    
                    // Se non è stata ancora impostata, calcolala
                    if (circleRestLeft === 0) {
                        circleRestLeft = window.innerWidth / 2;
                    }
                    
                    // Calcola l'offset corretto per mobile
                    const isMobile = window.innerWidth <= 768;
                    const circleBottomOffset = isMobile ? 80 : CIRCLE_REST_BOTTOM;
                    
                    // Determina l'altezza finale del menu basandosi sulla posizione finale del cerchio
                    const closedRestTop = window.innerHeight - circleBottomOffset - CIRCLE_SIZE / 2;
                    const finalDragUpDistance = closedRestTop - currentCircleTop;
                    const finalMenuHeight = Math.max(0, Math.min(MENU_HEIGHT, finalDragUpDistance));
                    
                    // Se il menu è più della metà aperto, completa l'apertura, altrimenti chiudilo
                    if (finalMenuHeight > MENU_HEIGHT * 0.5) {
                        // Apri completamente
                        menuOpen = true;
                        if (bottomMenu) {
                            bottomMenu.classList.add('open');
                            bottomMenu.style.height = MENU_HEIGHT + 'px';
                        }
                    } else {
                        // Chiudi completamente
                        menuOpen = false;
                        if (bottomMenu) {
                            bottomMenu.classList.remove('open');
                            bottomMenu.style.height = '0px';
                        }
                    }
                    
                    // Aggiorna la posizione di riposo finale
                    updateCircleRestPosition();
                    
                    // Calcola velocità basata sullo spostamento
                    const velocityX = (currentCircleLeft - dragStartLeft) * 0.3;
                    const velocityY = (currentCircleTop - dragStartTop) * 0.3;
                    
                    // Applica fisica a molla
                    animateSpring(circleRestLeft, circleRestTop, currentCircleLeft, currentCircleTop, velocityX, velocityY);
                    
                    // Reset hasMoved dopo un breve delay per permettere click successivi
                    // (verrà resettato anche alla fine dell'animazione a molla)
                    setTimeout(() => {
                        hasMoved = false;
                        totalDragDistance = 0;
                    }, 100);
                }
            });

            // Touch support
            let totalTouchDistance = 0;
            
            logoCircle.addEventListener('touchstart', (e) => {
                e.preventDefault();
                e.stopPropagation();
                
                if (springAnimId) {
                    cancelAnimationFrame(springAnimId);
                    springAnimId = null;
                }
                
                // Rimuovi transizione per movimento fluido durante il drag
                logoCircle.style.transition = 'none';
                if (bottomMenu) {
                    bottomMenu.classList.add('dragging');
                }
                
                isDragging = true;
                hasMoved = false;
                totalTouchDistance = 0;
                dragStartX = e.touches[0].clientX;
                dragStartY = e.touches[0].clientY;
                
                const pos = getCirclePosition();
                dragStartLeft = pos.left;
                dragStartTop = pos.top;
                currentCircleLeft = dragStartLeft;
                currentCircleTop = dragStartTop;
                
                // Aggiorna il menu in base alla posizione iniziale del cerchio
                // Questo assicura che il menu parta dalla posizione corretta quando si inizia un nuovo drag
                updateMenuHeightFromCircle(dragStartTop);
                
                logoCircle.classList.add('dragging');
            }, { passive: false });

            document.addEventListener('touchmove', (e) => {
                if (isDragging && logoCircle) {
                    e.preventDefault();
                    const deltaX = e.touches[0].clientX - dragStartX;
                    const deltaY = e.touches[0].clientY - dragStartY;
                    
                    // Calcola la distanza totale del drag
                    totalTouchDistance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                    
                    if (Math.abs(deltaX) > 5 || Math.abs(deltaY) > 5) {
                        hasMoved = true;
                    }
                    
                    // Applica rapporto 3/4 al movimento del touch
                    const moveRatio = 0.75;
                    currentCircleLeft = dragStartLeft + (deltaX * moveRatio);
                    currentCircleTop = dragStartTop + (deltaY * moveRatio);
                    
                    const minLeft = CIRCLE_SIZE / 2;
                    const maxLeft = window.innerWidth - CIRCLE_SIZE / 2;
                    const minTop = CIRCLE_SIZE / 2;
                    const maxTop = window.innerHeight - CIRCLE_SIZE / 2;
                    
                    currentCircleLeft = Math.max(minLeft, Math.min(maxLeft, currentCircleLeft));
                    currentCircleTop = Math.max(minTop, Math.min(maxTop, currentCircleTop));
                    
                    setCirclePosition(currentCircleLeft, currentCircleTop);
                    
                    // Aggiorna sempre l'altezza del menu in base alla posizione del cerchio durante il drag
                    // Il menu deve seguire il cerchio in tempo reale
                    updateMenuHeightFromCircle(currentCircleTop);
                }
            }, { passive: false });

            document.addEventListener('touchend', (e) => {
                if (isDragging) {
                    isDragging = false;
                    logoCircle.classList.remove('dragging');
                    
                    if (bottomMenu) {
                        bottomMenu.classList.remove('dragging');
                    }
                    
                    // Se il drag è minore di 8px, considera come click e apri/chiudi menu
                    if (totalTouchDistance < 8) {
                        // Usa toggleMenu() che legge la posizione corrente reale del cerchio
                        toggleMenu();
                        
                        // Reset immediato per permettere click successivi
                        hasMoved = false;
                        totalTouchDistance = 0;
                        return;
                    }
                    
                    // Calcola l'offset corretto per mobile
                    const isMobileTouch = window.innerWidth <= 768;
                    const circleBottomOffsetTouch = isMobileTouch ? 80 : CIRCLE_REST_BOTTOM;
                    
                    // Determina l'altezza finale del menu basandosi sulla posizione finale del cerchio
                    const closedRestTop = window.innerHeight - circleBottomOffsetTouch - CIRCLE_SIZE / 2;
                    const finalDragUpDistance = closedRestTop - currentCircleTop;
                    const finalMenuHeight = Math.max(0, Math.min(MENU_HEIGHT, finalDragUpDistance));
                    
                    // Se il menu è più della metà aperto, completa l'apertura, altrimenti chiudilo
                    if (finalMenuHeight > MENU_HEIGHT * 0.5) {
                        // Apri completamente
                        menuOpen = true;
                        if (bottomMenu) {
                            bottomMenu.classList.add('open');
                            bottomMenu.style.height = MENU_HEIGHT + 'px';
                        }
                    } else {
                        // Chiudi completamente
                        menuOpen = false;
                        if (bottomMenu) {
                            bottomMenu.classList.remove('open');
                            bottomMenu.style.height = '0px';
                        }
                    }
                    
                    // Aggiorna la posizione di riposo finale
                    updateCircleRestPosition();
                    
                    if (circleRestLeft === 0) {
                        circleRestLeft = window.innerWidth / 2;
                    }
                    
                    const velocityX = (currentCircleLeft - dragStartLeft) * 0.3;
                    const velocityY = (currentCircleTop - dragStartTop) * 0.3;
                    animateSpring(circleRestLeft, circleRestTop, currentCircleLeft, currentCircleTop, velocityX, velocityY);
                    
                    // Reset hasMoved dopo un breve delay per permettere click successivi
                    // (verrà resettato anche alla fine dell'animazione a molla)
                    setTimeout(() => {
                        hasMoved = false;
                        totalTouchDistance = 0;
                    }, 100);
                }
            });

            // Chiudi menu quando si scrolla
            let scrollTimeout;
            window.addEventListener('scroll', () => {
                if (menuOpen && !isDragging) {
                    clearTimeout(scrollTimeout);
                    scrollTimeout = setTimeout(() => {
                        if (menuOpen) {
                            toggleMenu();
                        }
                    }, 100);
                }
            }, { passive: true });

            // Aggiorna posizione su resize
            window.addEventListener('resize', () => {
                if (!isDragging && !springAnimId) {
                    updateCircleRestPosition();
                    circleRestLeft = window.innerWidth / 2;
                    setCirclePosition(circleRestLeft, circleRestTop);
                }
            });
        }
    }
    
    // Verifica periodica della posizione del cerchio per correggere eventuali problemi
    function verifyCirclePosition() {
        if (!logoCircle || isDragging || springAnimId) return;
        
        const pos = getCirclePosition();
        // Calcola l'offset corretto per mobile
        const isMobile = window.innerWidth <= 768;
        const circleBottomOffset = isMobile ? 80 : CIRCLE_REST_BOTTOM;
        const expectedBottom = window.innerHeight - circleBottomOffset - CIRCLE_SIZE / 2;
        const centerThreshold = window.innerHeight / 2;
        
        // Tolleranza adattiva basata sull'altezza dello schermo (più tolleranza su mobile)
        const tolerance = Math.max(50, window.innerHeight * 0.1);
        const isAtCenter = Math.abs(pos.top - centerThreshold) < tolerance;
        const isAtExpectedBottom = Math.abs(pos.top - expectedBottom) < tolerance;
        
        // Se il menu è chiuso e il cerchio non è nella posizione corretta, correggilo
        if (!menuOpen && !isAtExpectedBottom && !isAtCenter) {
            // Il cerchio potrebbe essere in una posizione intermedia, forzalo nella posizione corretta
            updateCircleRestPosition();
            circleRestLeft = window.innerWidth / 2;
            setCirclePosition(circleRestLeft, circleRestTop);
        } else if (!menuOpen && isAtCenter) {
            // Il cerchio è ancora al centro quando dovrebbe essere in basso, correggilo
            circleRestTop = expectedBottom;
            circleRestLeft = window.innerWidth / 2;
            setCirclePosition(circleRestLeft, circleRestTop);
        }
    }
    
    // Verifica la posizione periodicamente (ogni secondo) dopo che la pagina è caricata
    // Su mobile, verifica più spesso inizialmente
    const isMobile = window.innerWidth <= 768;
    const initialDelay = isMobile ? 1500 : 2000;
    const checkInterval = isMobile ? 500 : 1000;
    
    setTimeout(() => {
        // Verifica immediata dopo il delay iniziale
        verifyCirclePosition();
        // Poi verifica periodicamente
        setInterval(verifyCirclePosition, checkInterval);
    }, initialDelay);
    
    // Inizializza quando l'animazione CSS è completata
    // NOTA: initializeCirclePhysics viene chiamata dopo che l'animazione moveToBottomAndRotate è completata
    // nel codice sopra, quindi non serve chiamarla qui se il cerchio ha la classe loaded
    if (logoCircle) {
        // Usa animationend event se disponibile come fallback aggiuntivo
        logoCircle.addEventListener('animationend', (e) => {
            // Supporta sia l'animazione desktop che mobile
            if (e.animationName === 'moveToBottomAndRotate' || 
                e.animationName === 'moveToBottomAndRotateMobile' || 
                logoCircle.classList.contains('loaded')) {
                // Verifica la posizione dopo l'animazione
                // Su mobile, aspetta un po' di più
                const isMobile = window.innerWidth <= 768;
                const delay = isMobile ? 150 : 100;
                setTimeout(() => {
                    verifyCirclePosition();
                }, delay);
                return;
            }
            // Altrimenti inizializza normalmente (per l'animazione iniziale)
            if (!logoCircle.classList.contains('loaded')) {
                initializeCirclePhysics();
            }
        }, { once: false });
        
        // Fallback con timeout nel caso animationend non funzioni
        // Solo se non è già loaded (altrimenti viene gestito nel codice sopra)
        // Su mobile, aspetta più tempo
        const isMobileDeviceFallback = window.innerWidth <= 768;
        const fallbackDelay = isMobileDeviceFallback ? 2000 : 1500;
        
        setTimeout(() => {
            if (!logoCircle.classList.contains('loaded')) {
                initializeCirclePhysics();
            } else {
                // Se è già loaded, verifica comunque la posizione
                verifyCirclePosition();
                // Forza un'inizializzazione se necessario
                setTimeout(() => {
                    if (!isDragging && !springAnimId) {
                        const pos = getCirclePosition();
                        // Calcola l'offset corretto per mobile
                        const isMobile = window.innerWidth <= 768;
                        const circleBottomOffset = isMobile ? 80 : CIRCLE_REST_BOTTOM;
                        const expectedBottom = window.innerHeight - circleBottomOffset - CIRCLE_SIZE / 2;
                        const centerThreshold = window.innerHeight / 2;
                        const tolerance = Math.max(50, window.innerHeight * 0.1);
                        
                        if (Math.abs(pos.top - centerThreshold) < tolerance && !menuOpen) {
                            initializeCirclePhysics();
                        }
                    }
                }, 200);
            }
        }, fallbackDelay);
    }
    // Reset della selezione del menu quando si torna indietro con le frecce
    // Questo risolve il problema della scritta dell'ultima scelta ancora selezionata
    window.addEventListener('popstate', () => {
        // Piccolo delay per permettere al browser di navigare
        setTimeout(() => {
            // Se siamo sulla pagina masonry-grid, resetta la selezione
            const activeLink = sessionStorage.getItem('activeMenuLink');
            if (activeLink) {
                // Rimuovi la selezione attiva
                sessionStorage.removeItem('activeMenuLink');
                // Rimuovi la classe active da tutti i menu items
                document.querySelectorAll('.menu-item').forEach(item => {
                    item.classList.remove('active');
                });
            }
        }, 0);
    });
    
    // Reset anche quando la pagina viene mostrata (per gestire il caso di navigazione)
    window.addEventListener('pageshow', (e) => {
        // Se la pagina è stata caricata dalla cache (back/forward), resetta la selezione
        if (e.persisted) {
            const activeLink = sessionStorage.getItem('activeMenuLink');
            if (activeLink) {
                sessionStorage.removeItem('activeMenuLink');
                document.querySelectorAll('.menu-item').forEach(item => {
                    item.classList.remove('active');
                });
            }
        }
    });
})();
</script>
</body>
</html>
